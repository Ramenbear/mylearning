1.http和https
    1.http和https基本概念
        1.http:基于TCP/IP协议,网络应用层协议,超文本传输协议
             一个客户端和一个服务端请求和应答的标准
             用于从web服务器传输超文本到本地浏览器的传输协议
             快速:无状态连接
             请求格式:
                请求行、请求头部、空行、请求数据
             响应格式:
                状态行、消息报头、空行、响应正文
        2.请求方法
            HTTP1.0定义了三种方法:GET/POST/HEAD
            HTTP1.1新增了五种方法:OPTIONS/PUT/DELETE/TRACE/CONNECT
            HTTP2.0新的二进制格式
                HTTP1.x的解析基于文本,基于文本协议的格式解析存在天然缺陷,文本的表现形式多样性
                二进制则不同,只认0/1,实现方便且更健壮
        3.多路复用
            连接共享,一个request对应一个id,一个连接就可以有多个request
            每个连接的request可以随机混杂在一起,接受方根据request的id将request归属不同的服务端请求
        4.header压缩
            HTTP2.0使用encoder来减少需要传输的header大小
            通讯双方各自cache一份header fields表
            既避免了重复header的传输,又减少了需要传输的大小
        5.服务端推送(server push)
        https:安全的HTTP通道,加入了SSL层
    2.加密
        1.对称加密
            生成一把密钥,对数据进行加密,最后传输密钥,用密钥解密
            密钥的传输不安全,密钥一旦被截取,也就不安全了
        2.非对称加密
            客户端和服务器都拥有两把密钥
            一把密钥是公开的,一把密钥是私有的
            用公钥加密的数据只有相应的私钥才能解密
            用私钥加密的数据只有相应的公钥才能解密
            速度慢了很多
            中间人截取公钥,冒充服务器的公钥,数据还是被中间人截获
        3.数字证书
            大家都相信,大家都认可的认证中心(CA)
            服务器在给客户端传输公钥的过程中,会把公钥以及服务器的个人信息通过Hash算法生成信息摘要
            为了防止信息摘要被调换,还需要CA提供的私钥对其进行加密形成数字签名
            数字证书:没有通过Hash算法之前的个人信息以及公钥和数字签名合并在一起
            客户端收到这份数字证书后用CA提供的公钥对数字证书里的数字签名进行解密得到一份信息摘要
            然后对数字证书里的服务器公钥以及个人信息进行Hash得到另一份信息摘要
            通过两份摘要的对比,判断是否来自服务器
            证书是向认证中心申请
    4.https的工作原理
        客户通过https url访问服务器,要求服务器建立ssl链接
        服务器接受到了请求之后,返回网站的证书(携带了公钥)
        双方协商一致的安全等级,建立会话密钥,然后通过网站的公钥加密会话密钥,传送给网站
        web服务器通过自己的私钥解密会话密钥
        web服务器通过会话密钥加密与客户端之间的通信
    5.https的优点
        可认证用户和服务器,确保数据发送到准确的客户机和服务器
        更安全,防止数据在传输过程中不被窃取、改变
        现行架构下的最安全解决方案,不是绝对安全,大幅增加了中间人的攻击成本
    6.https缺点
        握手更加费时间,页面加载时间延长50%,增加10~20%的费电
        增加数据开销
        SSL证书需要钱,越高级越贵
        SSL证书需要绑定IP,不能在同一个IP上绑定多个域名,IPv4支持不了
2.TCP/UDP
    1.TCP传输需要建立连接,UDP不需要建立连接
    2.TCP提供可靠性传输,UDP尽最大努力交付,不保证可靠交付
    3.TCP是面向字节流,UDP面向报文,并且网络出现阻塞不会降低发送速率
    4.TCP是1对1的,UDP支持1对1,1对多
    5.TCP首部较大为20字节,UDP为8字节
4.HTTP请求的方式
    head:类似于get请求,只不过返回的响应中没有具体的内容,用户获取报头
    options:允许客户端查看服务器性能,比如支持的请求方式

9.HTTP2.0
    提升访问速度
    允许多路复用,同时通过单一的HTTP连接发送多重请求响应信息
    二进制分帧,将所有信息分割为更小的信息或帧,并进行二进制编码
    首部压缩
    服务器端推送
11.fetch
    fetch发送post请求时,第一次是发送一个options请求,询问是否支持修改的请求头
    待服务器支持,第二次发送真正的请求
22.iframe通信
    同源:根据父页面和cookie
    不同源:设置子域
23.HTTP常见请求头
    1.Accept:可接受的响应内容类型
        Charset:字符集
        Encoding:编码方式
        Language:语言列表
        Connection
        Cookie
        Date
        Host
        User-Agent
26.GET/POST
    1.get用于取回数据,post用于提交数据
        get常被用于取回数据,但是post也被ui框架用于取回数据
        比如kendo ui中的grid,就是用post来接受数据
        get是querystring,仅支持urlcode编码,post放在body,支持多种编码
    2.get的请求长度最多为1024kb,post对请求数据没有限制
        HTTP协议从未规定GET/POST的请求长度限制是多少
        GET的最大长度显示是因为浏览器和web服务器限制了URL的长度
    3.post比get安全性更高
        安全是相对性的,并不是真正意义上的安全
        通过get提交的数据都将显示在url上,页面会被浏览器缓存
        其他人查看历史记录会看见提交的数据,而post不会
        通过get提交的数据还可能会造成CSRF攻击
    4.GET产生一个TCP数据包,POST产生两个TCP数据包
    5.GET默认将属性拼接到URL上作为query,URL长度有限制
    6.POST请求放在一个请求体
    7.get请求类似于查找的一个过程,用户获取数据,可以不用每次都和数据库建立连接,可以使用缓存
        post一般是修改删除操作,必须和数据库进行交互,不能使用缓存,get更适合请求缓存
39.浏览器引擎
    Firefox：Gecko 引擎
    Safari：WebKit 引擎
    Chrome：Blink 引擎
    IE: Trident 引擎
40.浏览器中使用缓存的流程
    浏览器发起请求
    检查是否有缓存
    有Pragma字段 no-cache 强制请求 新资源
    有缓存并且没有Pragma,先判断缓存是否过期（Cache-Control 优先于 Expires），没有过期就使用缓存
    缓存有效时间过期了,查看是否使用了Eatg 和 Last-Modified 头部
    发送 If-none-Match 和 If-Modified-Since 去验证是否缓存还能继续使用
    (可能缓存到期了，但是服务端没有修改，而资源又比较大，通过校验可以减少网络传输)
    资源没有修改就使用缓存
    资源修改了就返回新的资源
    缓存使用的一些注意点

    Expires
    一般使用Cache-Control和Expires共存，主要是为了兼容http1.0
    Expires返回的是服务器时间，需要考虑服务器与客户端的时间同步（时区等）
    过期之后重新返回的响应中要加入新的Expires

    Cache-Control
    max-age 过期时间是一个时间段，从接受到这个响应之后开始生效，过期之后任然可以使用这个时间段
    max-age 和 Expires 共存的时候使用max-age
    no-cache 表示可以缓存，但是在使用缓存之前需要向服务器验证
    no-store 不缓存

    Last-Modified
    用来标识服务端最后一次修改资源的时间
    配合If-Modified-Since使用，检查缓存与服务端是否一致

    Etag
    服务端资源的唯一标识,看作一种数字签名
    当资源没有发送变化的情况下,Etag计算值不发生变化
    当有多个服务端的情况下,需要保证不同服务器上的Etag计算方式一致
    需要额外的计算Etag的资源