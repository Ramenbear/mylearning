1.node.js介绍
    1.提供一种简单的、用于创建高性能服务器及可在该服务器中运行的各种应用程序的开发工具
        传统服务端语言Java/PHP/ASP.NET语言,每个客户端连接创建一个新的线程
        一个线程大约需要消耗2MB的内存,一个8GB内存服务器同时连接的最大用户量大约4000个
        node.js修改了客户端与服务器端的连接方法,不是创建一个新的线程
        而是为每一个客户端连接触发一个在node.js内部进行处理的事件
        可以同时处理多达几万个的客户端连接
    2.V8 JavaScript脚本语言,一种被V8 JavaScript引擎所解析并执行的脚本语言
    3.node.js采用了两种机制
        1.非阻塞型I/O
            只支持单线程,不需要担心死锁的问题
            执行访问数据库的代码之后,立即转而执行其后的代码
            将数据库返回结果放在回调函数里执行
        2.事件环
            node.js一个时刻只能执行一个事件回调函数,但是可以中途转而处理其他事件
            比如触发新事件、声明该事件的回调函数,然后继续执行原来事件回调函数
    4.适合开发哪些应用程序
        1.聊天服务器
            同一时间存在大量用户与服务器之间的并发连接,服务器本身不存在非常复杂的处理
        2.综合服务类或电子商务网站的服务器
            每秒接受成千上万条数据并且需要写入数据库
            node.js通过队列机制将这些数据迅速写在缓存区
            然后通过每一个单独的处理从缓存区取出这些数据并写到数据库
            并且同时实现数据到数据库的写入,不需要单独等待一段时间
    5.node.js模块
        node.js通过模块来划分功能,每一个模块为一个js文件
        每一个模块定义的全局变量或函数的作用范围也被限定在这个模块之内
        只有通过exports对象才能将其传递到外部
        exports.printFoo = function(){return "foo"}
        引用模块,需要使用require函数
        var foo = require('./foo.js');
        console.log(foo.printFoo());
2.node.js中的交互运行环境-REPL
    node进入,可以用来测试JS脚本代码
3.node.js基础知识
    1.控制台
        console对象代表控制台
        1.console.log方法/console.info
            进行标准输出流的输出
            默认情况输出到控制台
            可以重定向输出到文件中,1代表重定向标准输出流
            node app.js 1>info.log
        2.console.error方法/console.warn
            进行标准错误输出流的输出
            2代表重定向标准错误输出流
        3.console.dir方法
            查看一个对象中的内容将该对象的信息输出到控制台
        4.console.time方法与console.timeEnd方法
            统计一段代码的执行时间,标记开始时间与标记结束时间
        5.console.trace方法
            将当前位置处的栈信息作为标准错误信息进行输出
        6.console.assert方法
            对一个表达式的结果进行评估
    2.全局作用域及全局函数
        1.全局作用域
            在一个模块中定义的变量、函数或方法只能在该模块中使用
            可以通过exports对象的使用将其传递到模块外部
            仍然存在一个全局作用域,可以定义不需要任何模块的加载即可使用的变量、函数或类
            node中定义了一个global对象,代表node的全局命名空间
            任何全局变量、函数或对象都是该对象的一个属性值
        2.setTimeout函数与clearTimeout函数
            在当前时刻过去多少毫秒之后执行某个回调函数
            具体延迟取决于外部因素,操作系统的时间粒度
        3.setInterval函数与clearInterval函数
            在当前时刻过去后每隔多少毫秒执行某个回调函数
            具体延迟取决于外部因素,操作系统的时间粒度
        4.定时器对象的unref方法与ref方法
            setTimeout与setInterval均返回一个定时器对象
            unref与ref方法可以取消函数中指定的回调函数的调用
        5.与模块相关的全局函数及对象
            1.使用require函数加载模块
            2.使用require.reslve函数查询完整模块名
            3.require.cache对象
                缓存了所有已被加载模块的缓存区
                可以使用console.log(require.cache)查看该缓存区中的内容
    3.__filename变量与__dirname变量
        1.__filename变量
            获取当前模块文件的带有完整绝对路径的文件名
        2.__dirname变量
            获取当前模块文件所在目录的完整绝对路径
    4.事件处理机制及事件环机制
        node中的事件,接受到客户端的请求,产生连接错误
        1.EventEmitter类
            实现事件处理的event模块,定义了一个EventEmitter类
            所有可能触发事件的对象都是一个继承了EventEmitter类的子类的实例对象
        2.EventEmitter类的各个方法
            1.对指定事件绑定事件处理函数
                on方法和addListener方法,第一个参数为指定事件名,第二个参数为事件的事件处理函数
            2.setMaxListeners修改最多可以绑定的事件处理函数数量
            3.取得一个指定事件的所有事件处理函数listeners
            4.once当事件处理函数执行一次后立即被解除
            5.解除某个事件处理函数removeListener
            6.解除所有removeAllListeners
            7.手工触发某个对象的一个事件时,emit方法
        3.获取指定事件的事件处理函数的数量
            listenerCount
        4.EventEmitter类自身所拥有的事件
            newListener/removeListener
        5.事件环机制
    5.使用调试器
4.模块与npm包管理工具
    1.核心模块与文件模块
        在node中,以模块为单位划分所有功能,每一个模块都是一个JS脚本文件
        可以自己编写或从网上下载以下几种模块文件
        1.后缀名为.js的JS脚本文件
        2.后缀名为.json的JSON文本文件
        3.后缀名为.node的经过编译的二进制模块文件
    2.从模块外部访问模块内部的成员
        1.使用exports对象
        2.将模块定义为类
            也可以将exports对象书写成"module.exports",将模块定义为一个类的时候
            var _name, _age;  //私有变量
            var name='', age=0;  //公有变量
            //模块对象的构造函数
            var foo = function(name, age){
                _name = name;
                _age = age;
            }
            //公有函数
            //获取私有变量_name的变量值
            foo.prototype.GetName = function(){
                return _name;
            };
            //设置私有变量_name的变量值
            foo.prototype.SetName = function(name){
                _name = name;
            };
            //获取私有变量_age的变量值
            foo.prototype.GetAge = function(){
                return _age;
            };
            //设置私有变量_age的变量值
            foo.prototype.SetAge = function(age){
                _age = age;
            };
            foo.prototype.name = name;
            foo.prototype.age = age;
            module.exports = foo;
        3.为模块类定义类变量或类函数
    3.组织与管理模块
        1.从node_modules目录中加载模块
            如果只指定文件名,不指定路径
            node将该文件视为node_modules目录下的一个文件
        2.使用目录来管理模块
            将目录名指定为模块名,以便可以通过目录来管理模块,只需为该目录指定一个入口点
        3.从全局目录中加载模块
            操作系统的环境变量中设置了NODE_PATH变量,从此寻找并加载该模块文件
    4.模块对象的属性
        module.id:当前模块的ID
        module.filename:属性值为当前模块文件的文件名
        module.loaded:布尔值,模块是否加载完毕
        module.parent:当前模块的父模块
        module.children:一个数组,存放了当前模块的所有子模块对象
    5.包与npm包管理器
        通过包来对一组具有相互依赖关系的模块进行统一管理
        一个包事实上就是一个目录
        bin:存放二进制文件
        lib:存放JS文件
        doc:包或包的使用方法进行说明的文档文件
        test:对包进行单元测试用的文件
5.使用Buffer类处理二进制数据
    在客户端JS脚本代码,对二进制数据没有很好的支持
    在处理TCP流或者文件流,必须要处理二进制数据
    Buffer类专门存放二进制数据的缓存区
    1.创建Buffer对象
        Buffer类是一个可以在任何模块中被利用的全局类,直接使用new来创建实例对象
        1.将缓存区大小指定为构造函数的参数
            new Buffer(size)
        2.直接使用一个数组来初始化缓存区
        3.直接使用一个字符串来初始化缓存区
    2.字符串的长度与缓存区的长度
        计算字符串的时候以一个文字为一个单位,计算缓存区的时候以字节作为单位
        字符串一旦创建不可修改
        Buffer对象是可以被修改的
    3.Buffer对象与字符串对象之间的相互转换
        1.Buffer对象的toString方法
        2.Buffer对象的write方法
        3.StringDecoder对象
    4.Buffer对象与数值对象之间的相互转换
    5.Buffer对象与JSON对象之间的相互转换
        可以使用JSON.stringify将Buffer对象中保存的数据转换为一个字符串
        也可以使用JSON.parse将一个经过转换后的字符串还原称谓一个数组
    6.复制缓存数据
        copy方法
    7.Buffer类的类方法
        1.isBuffer:判断一个对象是否为一个Buffer对象
        2.byteLength:计算一个指定字符串的字节数
        3.concat:将几个Buffer对象创建为一个新的Buffer对象
        4.isEncoding:检测一个字符串是否为一个有效的编码格式
6.在node.js中操作文件系统
    1.同步方法与异步方法
        使用fs模块来实现所有有关文件及目录的创建、写入及删除操作
        方法中具有Sync后缀的均为同步方法,不含的则为异步方法
        同步方法:执行的操作结束之前,不能执行后续代码
        异步方法:将操作结果作为回调函数的参数进行返回,可以执行后续代码
    2.对文件执行读写操作
        1.文件的完整读写
            1.readFile/readFileSync
                1.readFile
                    fs.readFile(filename, [options], callback)
                    回调函数:
                        function(err, data){
                            //回调函数代码略
                        }
                2.readFileSync
                    fs.readFileSync(filename, [optyions])
            2.writeFile/writeFileSync
                1.fs.writeFile(filename, data, [options], callback)
                2.fs.writeFileSync(filename, data, [options])
            3.将一个字符串或一个缓存区中的数据追加到一个文件底部
                1.appendFile
                    fs.appendFile(filename, data, [options], callback)
                2.appendFileSync
                    fs.appendFileSync(filename, data, [options])
        2.从指定位置开始读写文件
            1.打开文件
                1.open
                    fs.open(filename, flags, [mode], callback)
                2.openSync
                    fs.openSync(filename, flags, [mode])
            2.从指定位置读写文件
                1.read
                    从指定位置读取文件,一直读到文件底部,将读取的内容输出到一个缓存区
                    fs.read(fd, buffer, offset, length, position, callback)
                    fd为open方法所使用的回调函数中返回的文件描述符
                    buffer为一个Buffer对象,用于指定将数据读取到那个缓存区
                    offset指定向缓存区写入数据的开始写入位置
                    length指定从文件中读取的字节数
                    position用于指定读取文件时的开始位置
                2.readFileSync
                   fs.read(fd, buffer, offset, length, position)
                3.write
                    fs.write(fd, buffer, offset, length, position, callback)
                4.writeSync
                    fs.writeSync(fd, buffer, offset, length, position)
            3.关闭文件
                1.close
                    fs.close(fd, [callback])
                2.closeSync
                    fs.closeSync(fd)
                3.写入数据,首先将该部分数据读到内存中,在将数据写入文件,数据读完不代表写完
                    还可能有一部分留在内存缓存区,此时关闭,会造成这部分数据丢失
                    此时使用fsync对文件同步操作,将内存缓存区的剩余数据全部写入文件
                    然后再关闭文件
    3.创建于读取目录
        1.创建目录
            mkdir创建目录
        2.读取目录
            readdir读取目录
    4.查看与修改文件或目录的信息
        1.查看目录或目录的信息
            stat/lstat查看一个文件或目录的信息
            区别:查看符号链接文件的信息,必须使用lstat方法
            同步方式查看-Sync
        2.检查文件或目录是否存在
            exists检查一个文件或目录是否存在
            同步方式-Sync
        3.获取文件或目录的绝对路径
            realpath
            同步方式-Sync
        4.修改文件访问时间及修改时间
            utimes
            同步方式-Sync
        5.修改文件或目录的读写权限
            chmod
            同步方式-Sync
    5.对文件或目录执行的其他操作
        1.移动文件或目录
            rename方法移动文件或目录,当移动后的路径与原路径为同一路径
            移动后的文件名或目录名与原文件名或目录名不同时,则执行文件或目录的重命名操作
        2.创建与删除文件的硬链接
            所谓文件的硬链接,实际上就是文件的一个或多个文件名
            我们可以通过某种特殊的操作为该文件再指定一个文件名
            就创建了一个硬链接,虽然看起来两个不同,但修改其中一个会改变另一个
            使用link创建硬链接,同步方式-Sync
            删除硬链接:unlink
        3.创建与查看符号链接
            符号链接,是一种特殊的文件,仅包含了另一个文件或目录的路径及文件名或目录名
            打开一个文件的符号链接文件进行编辑,操作系统自动打开符号链接中所指向的原文件进行编辑
            删除符号链接文件,不会删除原文件,删除原文件,不会删除符号链接文件,"断链"
            创建符号链接文件:symlink  同步方式-Sync
            读取符号链接:readlink  同步方式-Sync
        4.截断文件
            首先清除文件内容,然后修改文件尺寸的操作
            truncate-Sync
        5.删除空目录
            rmdir  同步方式-Sync
        6.监视文件或目录
            1.watchFile监视到文件被修改时执行某些处理
                unwatchFile取消当文件发生改变时所要执行的处理
            2.watch
                返回一个fs.FSWatcher对象,该对象拥有一个close方法
                停止对watch方法中指定监视的文件或目录所执行的监视操作
    6.文件流
        1.流的基本概念
            1.readFile:先将文件内容完整的读到缓存区,再从缓存区中读取文件内容
                writeFile:先将文件内容完整的读到缓存区,然后一次性将缓存区的内容写入到文件
                将文件内容视为一个整体,为其分配缓存区并且一次性将文件内容读取到缓存区
                在这个期间node不能执行任何其他处理
            2.read:不断将文件的一小块内容读入缓存区,最后从缓存区读
                write:将要书写的数据写到一个内存缓存区,待内存缓存区写满后再写入文件
                在这个期间允许node执行其他处理
            3.在很多场合下,我们并不关心整个文件的内容,只关注是否从文件中读取到了某些数据
                以及在读取到这些数据时所需要执行的处理
            4."流"
                在一个应用程序中,流是一组有序的、有起点和终点的字节数据的传输手段
                交换与传输数据的时候,总是先将该对象中包含的数据转换为各种形式的流数据
                (即字节数据),再通过流的传输,到达目的对象后再将流数据转换成该对象可使用的数据
            5.node中使用各种实现了stream.Readable接口的对象来将对象数据读取为流数据
                所有这些数据都是继承了EventEmitter类的实例对象,在读取数据的时候会触发各种事件
                可以使用flowing/非flowing模式来读取数据
                当使用flowing模式时,将使用操作系统的内部I/O机制来读取数据
                当使用非flowing模式时,必须显式调用对象的read方法读取数据
            6.用于读取数据的对象
                fs.ReadStream用于读取文件
                http.IncomingMessage客户端请求或服务端响应
                net.Socket代表一个socket对象
                child.stdout创建子进程的标准输出流
                child.stderr创建子进程的标准错误输出流
                process.stdin创建进程的标准输入流
                Gzip用于数据压缩
                Deflate
                DeflateRaw
                1.用于读取数据的对象将会触发的事件
                    readable当可以从流中读出数据时触发
                    data存放已读取到的数据的缓存区对象或一个字符串
                    end读取完所有数据时触发
                    err产生错误触发
                    close读取流数据的对象被关闭时触发
                2.用于读取数据的对象拥有的方法
                    read读取数据
                    setEncoding指定编码
                    pause通知对象停止触发data事件
                    resume通知对象恢复触发data事件
                    pipe设置一个数据通道
                    unpipe取消设置的通道
                    unshift绑定一个解析器,可以取消该解析器的绑定
            7.用于写入数据的对象
                fs.WriteStream用于写入文件
                http.ClientRequest用于写入HTTP客户端请求数据
                http.ServerResponse用于写入HTTP服务器端响应数据
                net.Socket用于读写TCP流或UNIX流
                child.stdin创建子进程的标准输出流
                process.stdout创建进程的标准输出流
                process.stderr创建进程的标准错误输出流
                Gunzip用于解压数据
                Inflate
                InflateRaw
                1.用于写入数据的对象将会触发的事件
                    drain用于write方法返回false之后触发
                    finish当end方法被调用且数据被全部写入操作系统缓存区时触发
                    pipe用于读取数据的对象的pipe方法被调用时触发
                    unpipe用于读取数据的对象的unpipe方法被调用时触发
                    error产生错误触发
                2.用于写入数据的对象拥有的方法
                    write写入数据
                    end没有数据再写入流中调用该方法
        2.使用ReadStream对象读取文件
            在fs模块中,可以使用createReadStream方法创建一个将文件内容读取为流数据的ReadStream对象
            fs.createReadStream(path, [options])
            path指定要被读取的文件的完整路径及文件名
        3.使用WriteStream对象写入文件
            在fs模块,可以使用createWriteStream方法创建一个将流数据写入文件中的WriteStream对象
            fs.createWriteStream(path, [options])
    7.对路径进行操作
        path模块,处理和转换路径的方法和属性
        1.normalize方法
            将非标准路径字符串转换成标准路径字符串
        2.join方法
            将多个参数值字符串结合为一个路径字符串
        3.resolve方法
            以应用程序根目录为起点,根据所有的参数值字符串解析出一个绝对路径
        4.relative方法
            获取两个路径之间的相对关系
        5.dirname方法
            获取一个路径中的目录名
        6.basename方法
            获取一个路径中的文件名
7.实现基于TCP与UDP的数据通信
    net模块与dgram模块分别实现基于TCP与UDP的数据通信
    1.使用net模块实现基于TCP的数据通信
        1.创建TCP服务器
            var server = net.createServer([options], [connectionListener])
            1.两个可选参数,optiopns参数值为一个对象,可以使用一个布尔类型
                1.false
                    服务器接收到客户端发送的一个FIN包,会回发一个FIN包
                2.true
                    服务器接收到客户端发送的一个FIN包,不会回发一个FIN包
                    服务器可以继续向客户端发送数据,不会继续接受客户端发送的数据
                    必须调用end方法来关闭此socket连接,默认为false
                connectionListener参数用于指定回调函数
                    function(socket){
                        //回调函数代码略
                    }
                在该回调函数中使用一个参数,参数值为该TCP服务器监听的socket端口对象
                返回创建的TCP服务器
                当客户端与服务端建立连接,触发connection事件
                也可以不使用connectionListener参数,转而对connection事件进行监听
            2.创建了TCP服务器后,可以使用listen方法通知服务器开始监听客户端连接
                1.server.listen(port, [host], [backlog], [callback])
                    port:要监听的端口号
                    host:要监听的IP地址或主机名
                    backlog:指定位于等待队列中的客户端连接的最大数量
                2.server.listen(path, [callback])   //使用unix端口的服务器
                3.server.listen(handle, [callback])
                    handle:socket句柄
            3.address方法
                查看该服务器所监听的地址信息
            4.getConnections方法
                查看当前TCP服务器建立连接的客户端数量
            5.maxConnections方法
                指定接受客户端连接的最大数量
            6.close方法
                显式指定服务器拒绝所有新的客户端连接
        2.socket端口对象
            1.可以使用adress方法获取该socket端口对象相关的地址信息
            2.读取客户端发送的流数据,每次接收到客户端发送的流数据时触发data事件
                可通过对该事件进行监听并且指定回调函数的方法来指定当服务器端监听
                socket端口对象接收到客户端发送的数据时所需要执行的处理
                scoket.on('data', function(data){
                    //回调函数代码
                });
                1.未使用socket对象的setEncoding方法指定编码,参数值为一个Buffer对象
                2.使用socket对象的setEncoding方法指定编码,参数值为一个字符串对象
            3.可以使用pipe方法将客户端发送的流数据书写到文件等其他目标对象中/unpipe
            4.pause方法暂停data事件的触发/resume恢复data事件的触发
            5.setTimeout指定与该端口相连接的客户端连接的超时时间/将timeout参数值指定为0取消
        3.创建TCP客户端
            创建一个用于连接TCP服务器的socket端口对象即可
            var net = new net.Socket([options])
            现在可以使用方法来连接服务器
            1.socket.connect(port, [host], [connectListener])
                port:指定需要连接的TCP服务器端口
                host:指定需要连接的TCP服务器地址,可以为一个IP地址,也可为一个主机名               
            2.socket.connect(path, [connectListener])
                与一个unix端口的服务器进行连接
            3.socket端口对象也可被用来写入向客户端或服务器端发送的数据
                当流数据被写入后,立即被发送到客户端或服务器端
                当需要写入流数据,使用socket端口对象的write方法
                socket.write(data, [encoding], [callback])
            4.在一个快速网络中,当数据量较少的时候,node总是将数据直接发送到操作系统专用于发送数据的
                TCP缓存区,然后从该TCP缓存区中取出数据发送给对方
              在一个慢速的网络中或需要发送大量数据时,TCP客户端或服务器端所发送的数据并不一定会立即
                被对方接收,node会将这些数据缓存在缓存队列中,在对方可以接收数据的情况下将缓存队列中
                的数据通过TCP缓存区发送给对方
              socket端口对象的write方法返回一个布尔类型的返回值,当数据直接被发送到TCP缓存区,该返回
                值为true,当数据首先被发送到缓存队列,该返回值为false且TCP缓存区中的数据已全部发送出
                去,触发drain事件
            5.创建TCP客户端
                var net = require('net');
                var client = new net.Socket();
                client.setEncoding('utf-8');
                client.connect(8431, 'localhost', function(){
                    console.log('已连接到服务器端');
                    client.write('你好');
                });
                client.on('data', function(data){
                    console.log('已连接到服务器端发送的数据: ' +data);
                });
            6.创建TCP服务器
                var net = require('net');
                var server = net.createServer();
                server.on('connection', function(socket){
                    console.log('客户端与服务器端连接已建立');
                    socket.setEncoding('utf-8');
                    socket.on('data', function(data){
                        console.log('已接收客户端发送的数据:' +data);
                        socket.write('确认数据：' +data);
                    });
                });
                server.listen(8431, 'localhost');
            7.捕捉错误,并删除该socket端口对象
                client.on('error', function(err){
                    console.log('错误信息', err.code);
                    client.destroy();
                });
                socket.on('error', function(err){
                    console.log('错误信息', err.code);
                    socket.destroy();
                });
            8.关闭连接
                socket.end([data], [encoding])
            9.TCP服务器的unref方法指定当客户端连接全部关闭时退出应用程序
            10.TCP服务器的ref方法阻止应用程序的退出
        4.net模块中的类方法
            1.isIP
            2.isIPv4
            3.isIPv6
    2.使用dgram模块实现基于UDP的数据通信
        UDP不需要建立连接,直接将数据发送给对方,不可靠协议,传输更快,用于实时通信
        1.创建UDP服务器与客户端
            1.在dgram模块,使用createSocket方法创建一个用于实现UDP通信的socket端口对象
                var socket = dgram.createSocket(type, [callback])
                type:指定进行UDP通信时使用的协议类型,udp4/udp6
                回调函数:
                    function(msg, rinfo){
                        //回调函数
                    }
                msg参数值为一个Buffer对象,存放接收到的数据
                rinfo参数值也为一个对象
            2.绑定所监听的地址与端口号,才知道往哪发送数据
                socket.bind(port, [address], [callback])
            3.发送数据
                socket.send(buf, offset, length, port, address, [callback])
            4.创建UDP服务器
                var dgram = require("dgram");
                var server = dgram.createSocket("udp4");
                server.on("message", function(msg, rinfo){
                    console.log('已接收客户端发送的数据: ' +msg);
                    console.log("客户端地址信息为%j", rinfo);
                    var buf = new Buffer("确认信息: " +msg);
                    server.send(buf, 0, buf.length, rinfo.port, rinfo.address);
                });
                server.on("listening", function(){
                    var address = server.address();
                    console.log("服务器开始监听,地址信息为%j", address);
                });
                server.bind(41234, 'localhost');
            5.创建UDP客户端
                var dgram = require('dgram');
                var message = new Buffer("你好");
                var client = dgram.createSocket("udp4");
                client.send(message, 0, message.length, 41234, "localhost", function(err, bytes){
                    if(err) console.log('发送数据失败');
                    else console.log("已发送%d字节数据", bytes);
                });
                client.on("message", function(msg, rinfo){
                    console.log("已接收服务端发送的数据: %s", msg);
                    console.log("服务器地址为: %s", rinfo.address);
                    console.log("服务器所用端口为: %s", rinfo.port);
                    client.close();
                });
                client.on("close", function(){
                    console.log("socket端口被关闭");
                });
            6.关闭socket端口对象
                socket.close()
            7.使用socket端口对象的unref方法允许应用程序正常退出
            8.取消UDP客户端socket端口的关闭
            9.ref取消unref的使用
            10.在网络中发送的每个数据包都拥有一个TTL值(Time to Live)值,用于标识一个数据包的生存时间
                每个路由器或网关在转发一个数据包的时候,都会消耗该数据包的一些TTL值,TTL为0的时候
                该数据包将被遗弃,在每个操作系统都设置了默认的TTL值,可以经过的最大路由器数目,默认为64
                在node中可以使用setTTL来自己设置
        2.实现广播与组播
            1.广播
                socket.setBroadcast(flag)
                使用一个布尔类型的参数,为true的时候,可以使用socket端口对象的send
                方法来进行数据的广播
            2.组播
                1.将网络中同一业务类型主机进行逻辑上的分组
                    从某个socket端口上发送的数据只被该组中的其他主机所接受
                    不被组外任何主机接收
                    不直接发给目标地址,而是发给组播地址,操作系统将数据组播给其他成员
                    socket.addMembership(multicastAddress, [multicastInterface])
                    multicastAddress:组播组地址
                    multicastInterface:网络接口IP地址
                2.退出组播
                    socket.dropMembership(multicastAddress, [multicastInterface])
                3.socket.setMulticastTTL(ttl)
                4.是否允许被主机的本地接口接受
                    socket.setMulticastLoopback(flag)
8.创建HTTP于HTTPS服务器及客户端
    1.HTTP服务器
        1.创建HTTP服务器
            1.调用HTTP模块中的createServer方法
                var server = http.createServer([requestListener])
                可以使用一个可选参数,为一个回调函数
                function(request, response){
                    //回调函数
                }
                第一个参数是一个http.IncomingMessage对象,代表一个客户端请求
                第二个参数是一个http.ServerResponse对象,代表一个服务器端响应对象
            2.指定监听地址
                server.listen(port, [host], [backlog], [callback])
            3.关闭服务器
                var http = require('http');
                var server = http.createServer(function (req, res){
                    //暂时不指定
                }).listen(1337, "127.0.0.1");
                server.on('listening', ,function(){
                    console.log('服务器开始监听');
                    server.close();
                });
                server.on('close', function(){
                    console.log('服务器已被关闭');
                });
            4.error错误
            5.connection连接
            6.setTimeout设置连接超时时间
        2.获取客户端请求信息
            HTTP服务器接受到客户端请求时调用的回调函数的第一个参数值为一个http.IncomingMessage对象
            用于读取客户端请求流中的数据,当从客户端请求流中读取到新的数据触发data事件
            当读取完数据时触发end事件
            1.在文件中保存客户端请求信息
                var http = require('http');
                var fs = require('http');
                var server = http.createServer(function (req, res){
                    if(req.url !== "/favicon.ico"){
                        var out = fs.createWriteStream('./request.log');
                        out.write('客户端请求所用的方法为:' +req.method+'\r\n');
                        out.write('客户端请求所用的url字符串为:' +req.url+'\r\n');
                        out.end('客户端请求所用的HTTP版本为:' +req.httpVersion);
                    }
                    res.end();
                }).listen(1337, "127.0.0.1");
        3.转换URL字符串与查询字符串
            url模块与Query String模块
            分别用来转换完整URL字符串与URL中的查询字符串
            1.查询字符串
                从?开始到#结束或者到URL字符串结束,这之间的称为查询字符串
                可以使用Query String模块的parse方法将该字符串转换成为一个对象
                stringify将一个对象转换成为一个查询字符串
            2.转换URL字符串
                url模块使用parse方法转换整个字符串
                format还原成一个字符串
                resolve将两个方法结合成为一个路径
        4.发送服务器端响应流
            第二个参数是一个http.ServerResponse对象,代表一个服务器端响应对象
            可以利用该对象发送服务器端响应流
            1.可以使用writeHead方法来发送响应头信息
                AJAX请求,这是跨域数据操作,需要在HTTP响应头中添加
                Access-Control-Allow-Origin字段
            2.也可以使用setHeader设置多个响应字段
            3.可以使用getHeader方法获取响应头中某个字段值
            4.removeHeader删除一个响应字段
            5.headersSent属性,响应头发送时为true,响应头未发送时为false
            6.statusCode获取HTTP服务器返回的状态码
    2.HTTP客户端
        1.向其他网站请求数据
            1.使用request方法向其他网站请求数据
                1.var req = http.request(options, callback)
                    options:指定请求的目标URL地址
                    request返回一个http.ClientRequest对象,代表一个客户端请求
                2.可以使用write向目标网站发送数据
                3.end结束本次请求
                4.abort终止本次请求
                5.建立连接的过程中,当为该连接分配端口时,触发socket事件
            2.使用GET方法
                区别:
                    get方法只能使用GET方式请求数据,get方法不需要调用end方法,自动调用
        2.向本地服务器请求数据
            1.用于发送数据的HTTP客户端
                var http = require('http');
                var options = {
                    hostname: 'localhost',
                    port: 1337,
                    path: '/',
                    method: 'POST'
                };
                var req = http.request(options);
                req.write('你好');
                req.end('再见');
            2.用于接受数据的HTTP服务器
                var http = require('http');
                var server = http.createServer(function (req, res){
                    if(req.url !== "/favicon.ico"){
                        req.on('data', function(data){
                            console.log('服务器端接收到数据: '+data);
                        });
                    }
                }).listen(1337, "127.0.0.1");
            3.制作代理服务器
                首先创建一个HTTP服务器,当服务器接受到客户端请求后,向xxx网站请求数据
                最后接收到响应数据,将响应数据发送给客户端
    3.创建HTTPS服务器与客户端
        https模块专用于创建HTTPS服务器与客户端
        1.区别:
            1.HTTPS使用HTTPS协议
            2.HTTPS服务器需要向CA中心申请证书
            3.HTTPS传输过程中传输的是经过加密后的SSL密文数据
            4.HTTPS使用443端口
            在实际场景中,私钥和公钥都保存在服务器端,在客户端与服务器端确认身份之前
            公钥会传送到客户端,客户端随机发送消息给服务器端,服务器端拿着收到的字符
            计算成hash值后用私钥加密再送给客户端,客户端收到数据后用公钥解密,也将它
            计算成hash值,检查是否一致,一致,则握手成功
            客户端选择一个加密算法和相应密钥并用公钥加密后,发送给服务器端
            服务器端接收到加密算法和密钥后,也就可以正式沟通数据了
        2.创建HTTPS服务器 
            创建前首先需要创建公钥、私钥、证书
            1.创建私钥
                使用openssl工具创建私钥
                openssl genrsa -out privatekey.pem 1024
            2.创建证书签名请求
                open req -new -key privatekey.pem -out certrequest.csr
            3.获取证书
                经过证书授权中心签名的文件,包含服务器端提供的公钥以及证书的颁发机构等信息
            4.有了这些证书就可以创建服务器了
                https.createServer(options, [requestListener])
        3.创建HTTPS客户端
            var req = https.request(options, callback)
9.进程与子进程
    在node中只支持单线程,但是在应用程序中,如果只使用单线程,从接受请求到返回响应需要很长的等待时间
    如果使用多进程,就可以为每个请求分配一个进程,更好地使用服务器端CPU资源
    node提供了child_process模块与cluster模块
    1.node中的进程
        每一个应用程序都是一个进程类的实例对象,node中使用process代表node应用程序
        1.进程对象的属性
            execPath:运行应用程序的可执行文件的绝对路径
            version:node版本
            versions:node及其各依赖的版本号
            platform:运行node的平台
            ......
        2.进程对象的方法和事件
            memoryUsage:应用程序的进程的内存使用量
            nextTick:将函数推迟到下一个同步方法执行完毕
            cwd:返回当前目录
            exit:退出当前应用程序的进程
            ......
    2.创建多进程应用程序
        child_process模块,当主进程运行之后,可以开启多个子进程
        在多个子进程之间可以共享内存空间,子进程之间进行通信来实现信息的交换
        多个子进程之间可以通过共享端口的方式来将请求分配给多个子进程
        1.使用spawn方法开启子进程
            child_process.spawn(command, [args], [options])
        2.使用fork方法开启子进程
            child_process.fork(modulePath, [args], [options])
        3.使用exec方法开启子进程
            child_process.exec(command, [options], [callback])
        4.使用execFile方法开启子进程
            child_process.execFile(file, [args], [options], [callback])
    3.在多个子进程中运行node应用程序
        一个node应用程序只能使用在一个线程中
        为了充分发挥多核CPU的优势,提供了一个cluster模块
        允许在多个子进程中运行不同的node应用程序
        1.使用fork方法创建worker对象
            在cluster模块中,可以使用fork方法开启多个子进程,在每个子进程中创建一个node应用程序实例
            并且可以在该应用程序中运行一个模块文件
            cluster.fork([env])
            fork方法返回一个隐式创建的worker对象
            代表使用fork方法开启的子进程中运行的node应用程序实例对象
            setupMaster方法修改需要在子进程中运行的模块文件
        2.worker对象的方法与事件
            1.当使用fork开启子进程后,会向主进程发送一个反馈信息,当主进程接受到这个反馈消息后
                触发online事件
            2.listening事件
            3.send方法
            4.kill方法
            5.disconnect方法                  
10.node.js中错误处理与断言处理
    1.使用domain模块处理错误
        1.domain模块概述
    2.node中断言操作
        assert模块进行断言处理,书写一些判断用测试代码
        1.equal/notEqual
        2.strictEqual/notStrictEqual
        3.assert/ok
        4.deepEqual/notDeepEqual
        5.throws/doesNotThrow
11.加密与压缩
    1.加密与解密操作
        1.cryrto模块
          node中OpenSSL类库被封装在crypto模块中
          包含了类似MD5或SHA-1之类的散列算法,也可以实现HMAC运算
          查看所有加密算法:
            crypto.getCiphers()
          查看所有散列算法:
            crypto.getHashes()
        2.散列算法
            散列(也称哈希)算法用来实现一些重要处理,在允许对一段数据进行验证的前提下
            将该数据模糊化,或者为一大段数据提供一个校验码
            首先需要创建一个hash对象
                crpto.createHash(algorithm)
            algorithm:在node中可以使用的算法,返回一个hash对象
            使用该对象的update创建一个摘要
                hash.update(data, [input_encoding])
            data:摘要内容  input_encoding:编码格式
            最后使用digest方法来输出摘要内容
                hash.digest([encoding])
        3.HMAC算法
            将一个散列算法与一个密钥结合在一起,阻止对签名完整性的破坏
            首先创建一个hmac对象
                crypto.createHmac(algorithm, key)
            key:指定一个PEM格式的密钥
                hmac.update(data)
                hmac.digest([encoding])
        4.公钥加密
            node提供以下4个与公钥加密相关的类
                Cipher类:用于加密数据
                Decipher类:用于解密数据
                Sign类:用于生成签名
                Verify:用于验证签名
            私钥用于解密数据以及对数据进行签名
            公钥用于创建只有私钥的拥有者才能够读出的加密数据
            以及对私钥的拥有者的签名进行验证
            1.加密数据
            2.解密数据
            3.创建签名
            4.验证签名
    2.压缩和解压缩处理
        zib模块
12.其他模块
    1.dns模块解析域名
    2.使用punycode模块转换punycode编码
    3.使用os模块获取操作系统信息
    4.使用readline模块逐行读取数据
    5.util模块
    6.使用vm模块改变脚本运行环境
    7.自定义REPL运行环境
13.数据库访问
    1.在MongoDB数据库中存取数据
        1.MongoDB概述
            MongoDB在JS脚本环境中支持BSON(JSON对象的二进制形式)的存取,数据存取效率高
            MongoDB将每一条等待插入的数据记录存储在内存中,非阻塞型数据库
            在需要记载大量日志数据、实时测量数据或实时统计数据
            而且支持在查询语句内部使用JS函数,也大大加强了读取数据的能力
            是一个面向文档的数据库,允许用户在父记录中存储子记录
            支持的数据类型:
                Array:数组
                Boolean:布尔
                Code:可运行一段JS代码
                Date:日期时间
                DBRef:数据库引用
                Integer:整数值
                Long:长整数值
                Hash:键值/键名
                Null:null值
                ObjectID:24位的十六进制字符串
                String:字符串
        2.安装MongoDB
        3.引入MongoDB模块
            var mongo = require('mongodb')
        4.连接MongoDB数据库
            1.先创建一个代表MongoDB数据库所在服务器的Server对象,用于指定需要连接数据库所在服务器
                var server = mongo.Server(host, port, [options])
            2.然后创建一个代表MongoDB数据库的Db对象
                var db = new mongo.Db(databaseName, server, [options])
            3.使用该Db对象的open方法执行数据库连接操作
                db.open(callback)
                执行数据库连接后的回调函数
                function(err, db){
                    //回调函数
                }
            4.当一个数据库不再需要使用的时候,使用close方法关闭此数据库
                db.close([forceClose], [callback])
            5.示例
                var mongo = require('mongodb');
                var host = "localhost";
                var port = mongo.Connection.DEFAULT_PORT;
                var server = new mongo.Server(host, port, {auto_reconnect:true});
                var db = new mongo.Db('node-mongo-examples', server, {safe:true});
                db.open(function(err, db){
                    if(err) throw err;
                    else{
                        console.log('成功建立数据库连接');
                        db.close();
                    }
                });
                db.on('close', function(err, db){
                    if(err) throw err;
                    else console.log('成功关闭数据库');
                });
        5.在MongoDB数据库中插入数据
            数据存储在许多数据集合中,就好像关系数据库中的数据表
            可以使用数据库对象的collection方法访问一个集合
                db.collection(collectionName, [options], [callback])
                function(err, collection){
                    //回调函数
                }
                第二个参数是一个collection对象,代表被访问的集合
            可使用collection对象的insert方法向该集合插入一个数据文档
            MongoDB数据库是一个面向文档的NoSQL数据库,每一条数据都是一个数据文档
            关系型数据库则是将一条数据称为一个数据记录
                collection.insert(docs, [options], [callback])
        6.在MongoDB数据库中查询数据
            可使用collection对象的find方法从一个集合中查询多个数据文档
                collection.find(selector, [options])
            返回一个代表游标的Cursor对象,包含了所有查询到的数据文档信息
            可以使用toArray方法获取所有查询到的数据文档
                collection.find(selector, [options]).toArray(callback);
        7.在MongoDB数据库中更新与删除数据
            1.可使用collection对象的update方法更新集合中的数据文档
                collection.update(selector, document, [options], [callback])
                function(err, result){
                    //回调函数
                }
                第二个参数为一个整数值,代表成功更新的数据条数
            2.也可以使用findAndModify查询并更新一条数据文档
                collection.findAndModify(selector, sort, document, [options], callback)
            3.使用remove方法删除集合中的数据文档
                collection.remove([selector], [options], [callback])
            4.使用findAndRemove方法查询并删除一条数据记录
                collection.findAndRemove(selector, sort, [options], callback)
        8.使用Mongoose类库
            使用Mongoose类库,可以使MongoDB数据库在node中得到一个全面的支持
            相对于MongoDB本地驱动来说,Mongoose类库可以为MongoDB数据库定制一个开发环境
            也可以在该开发环境为MongoDB数据库中的数据制作一些数据架构
            当使用MongoDB数据库时,不需要像关系数据库那样为数据定制数据架构
            只需要将数据文档保存在数据库中即可,之后就可以查询这些数据
            数据架构?
                在关系数据库中,在存储数据之前,必须首先为数据定义数据表,并且为数据定义一些字段
                从而实现数据模型
                因此在关系数据库,一个数据表就是一个数据架构
                数据架构也就指数据库中的数据模型定义,被独立于应用程序之外而单独定义
                预先定义开发者可以使用的数据模型
                MongoDB数据库与其他NoSQL数据库一样被认为无数据架构,不需要指定数据之间的相互关系
                事实上它也存在数据架构,在开发者存储数据时隐式创建的
                数据架构在MongoDB数据库是有用的,可以以一种使人易读的方式来描述数据库中的数据内容
                并且为这些数据指定一些规则
                通过数据架构的使用来进行数据库中数据的存取,提供了更容易使用且便于进行数据存储的接口
    2.在MySQL数据库中存取数据
        1.装包及引入模块
        2.建立连接与关闭连接
            1.使用createConnection方法创建一个表示与MySQL数据库服务器之间的连接的Connection对象
                var connection = mysql.createConnection(options);
                返回创建的Connection对象
            2.也可以使用Connection对象的connect方法建立与MySQL数据库服务器之间的连接
                connection.connect(function(err){
                    //回调函数
                })
            3.使用end/destory方法关闭与MySQL数据库之间的连接
            4.例子   
                var mysql = require('mysql');
                var connection = mysql.createConnection({
                    host      : 'localhost',
                    port      : 3306,
                    database  : 'mysql',
                    ueser     : 'root',
                    password  : 'root',
                });
                connection.connect(function(err){
                    if(err) console.log('与MySQL数据库连接失败');
                    else{
                        console.log('与MySQL数据库连接成功');
                        connection.end(function(err){
                            if(err) console.log('关闭MySQL数据库操作失败');
                            else{
                                console.log('关闭MySQL数据库操作成功');
                            }
                        });
                    }
                });
        3.执行数据的基本处理
            可通过Connection对象的query方法统一执行数据的增加、删除、查询及修改等基本处理
                connection.query(sql, [parameters], [callback]);
            为防止SQL注入攻击,需要使用Connection对象的escape方法对所有用户输入数据
            进行escape编码处理
                connection.escape(data);
            默认禁用多语句查询
            通过设置multipleStatements属性来开启多语句查询
        4.执行存储过程
            可以使用multipleStatements来执行存储过程
        5.执行多表结合查询
            通过query的第一个参数值SQL语句指定多张表的结合查询
        6.以数据流的方式处理查询数据
            有时用户会查询大量数据并希望单独处理每一条查询到的数据
            query返回一个可用于处理流数据的对象,如果要使用
            那么不能使用callback参数值指定回调函数
        7.创建连接池
            在开发一个web应用程序,连接池是一个非常重要的概念,建立一个数据库连接所消耗的性能成本比较大
            在服务器应用程序中,如果为每一个接收到的客户端请求都建立一个或多个数据库连接,严重影响性能
            通常是为多个数据库连接创建一个连接池,当连接不再需要使用的时候,这些可以缓存在连接池中
            当接受到下一个客户端请求时,可以从连接池中取出连接并重新利用,不再需要建立数据库连接
            1.创建连接池    
                var pool = mysql.createPool(options);
            2.有了连接池,可以直接使用连接池对象的getConnection方法从连接池获取一个方法
                如果连接池没有可用连接,则隐式创建一个数据库连接
                pool.getConnection(callback);
            3.当一个连接不再需要使用时,使用release方法归还连接池
            4.需要从连接池中移除,使用destroy方法
            5.不需要连接池,end方法关闭连接池
14.使用Express构建Web应用程序
    1.Express概述
        1.一个可以在node中使用的MVC框架
        2.开发一个简单示例
            var express = require('express');
            var app = express();
            app变量值为一个被创建的Express应用程序实例对象
            在应用程序实例对象创建之后,可以使用listen方法来指定服务器要监听的地址及端口
            app.listen(1337, "127.0.0.1");
            可使用get方法接受客户端提供的GET请求并返回服务器端响应的结果
            app.get(path, callback)
            function(request, response){
                //回调函数
            }
            示例:
            var express = require('express');
            var http = require('http');
            var app = express();
            app.get('/index.html', function(req, res){
                res.writeHead(200, {'Content-Type': 'text/html'});
                res.write('<head><meta charset="utf-8"></head>');
                res.end('你好\n');
            });
            app.listen(1337, "127.0.0.1");
            还提供了一个send方法,用于发送一个服务器端响应结果
            不再需要writeHead或setHeader来发送响应头
    2.设置路由
        使用路由来根据客户端请求提交的不同URL地址来返回不同的服务器端响应结果
        在路由中可以使用":"加参数名来指定一个参数
        也可以使用正则表达式
        可以使用通配符
    3.使用各种提交数据或请求数据的方法
        1.使用post方法接受客户端提交的POST方法
        2.使用put方法接受客户端提交的PUT方法
        3.使用delete方法接受客户端提交的DELETE方法
        4.使用all方法接受客户端提交的各种方法
    4.中间件
        1.允许通过中间件来调用第三方类库
            一个中间件是一个用于处理客户端请求的函数,一个HTTP服务器中会用到各种中间件
            当接受到一个客户端请求时,首先将该请求提交给第一个中间件函数
            每一个中间件函数内部封装一个next函数,在一个中间件函数内部可以
            判断是否调用next回调函数来处理该客户端请求
                function middleware(req, res, next){next()}
            使用use方法来调用一个中间件
                app.use([path], function)
        2.内置中间件
            1.basicAuth
                为网站添加身份认证功能
                在大多数情况下,需要通过数据库或其他资源的使用来验证用户输入的信息是否正确
                这时需要为中间件函数添加一个异步函数
                比如将用户的用户名密码存储在一个表里,完了就去这个表里查找
            2.bodyParser
                用于解析客户端请求的body中的内容
                内部使用JSON编码处理、url编码处理以及对于文件的上传处理
            3.cookieParser
                用于获取web浏览器发送的cookie中的内容
            4.logger
                记录详细的操作日志和错误日志
            5.methodOverride
                必须结合bodyParser一起用,为bodyParser提供伪HTTP方法支持
            6.responseTime
                用于在服务器端响应头添加一个X-Response-Time响应字段
                内容为服务器端生成响应数据的时间
            7.router
                为路由提供一些高级特性
                包括sinatra风格的路由特性以及对中间件函数的执行顺序的控制能力
            8.session
                用于保存用户数据的session管理器
                虽然session中的数据与cookie中的数据分开保存
                但是session中的数据经过加密处理后默认保存在一个cookie中
                因此必须需要使用cookieParser
            9.static
                可以使客户端直接访问网站中的所有静态文件
            10.directory
                用于在浏览器中列出网站某个目录下的所有子目录及文件
            11.异常处理机制
                触发一个错误时,隐式调用errorHandler中间件在控制台中输出错误,并向客户端返回该错误
            12.limit
                用于对客户端提交数据的字节数进行限制
        3.配置应用程序
            在一个正式的web应用程序或web网站中
            使用configure方法来统一配置,需要使用的内部变量及中间件
        4.模板引擎
            1.概述
                在一个web应用程序中,如果只通过服务器端代码来编写客户端HTML代码,造成大量工作量
                而且HTML代码将会难以阅读和维护
                如果只使用客户端静态HTML文件,那么服务器端逻辑很难融入到客户端HTML代码中
                为了使服务器端逻辑更好地融入客户端HTML代码,而且可以以文件形式来维护客户端HTML代码
                于是开发出了各种node模板引擎
            2.Jade模板引擎的使用方法
                1.安装
                    npm install jade
                2.使用
                    app.set('view engine', 'jade')
                3.默认情况下,所有视图文件需要放置在应用程序根目录的views子目录下
                    可以通过设置views内部变量值的方法显式指定视图文件的存放路径
                    app.set('views', __dirname+'/views')
                4.可以使用render方法来渲染一个视图
                    res.render(view, [locals], [callback])
                    function(err, html){
                        //回调函数
                    }
            3.EJS模板引擎的使用
15.使用Socket.IO类库实现WebSocket通信
    一个小类库,类似于node中的net模块
    包括websocket通信、XHR查询、JSONP轮询
    1.Socket.IO概述
        可以接受所有与服务器端相连接的客户端发送的消息,也可以向客户端发送消息
        在服务器端与浏览器之间提供一个共享接口
        也就是说当客户端与服务器端建立连接之后,在处理消息的时候开发者可以使用服务器端JS代码
        1.HTML5中的websocket通信
        2.可在Flash中使用websocket通信
        3.XHR轮询
        4.JSONP轮询
        5.Forever Iframe
    2.使用方法
        创建一个Socket.IO服务器即可,该服务器依赖于一个HTTP服务器
        在HTTP服务器运行之后,使用listen方法为该HTTP服务器附加一个Socket.IO服务器
            varsio = require('socket.io');
            var socket = sio.listen(server);
            server代表一个HTTP服务器,listen方法返回一个Socket.IO服务器
        在一个Socket.IO服务器创建之后,当客户端与服务器端建立连接时,触发一个connection事件
        可以通过监听该事件并指定事件回调函数的方法指定所需执行的处理
            socket.on('connection', function(socket){
                //回调函数
            });
        当接受到客户端发送的消息,触发message事件
            socket.on('message', function(msg){
                //回调函数
            });
        可以使用send方法向客户端发送一个消息
            socket.send(msg)
        断开连接,触发socket端口对象的disconnect事件
    3.在Express框架中使用Socket.IO
    4.在服务端保存用户数据
        建立连接后,可以在服务器端使用socket端口对象的set方法保存用户数据
        该数据在用户的当前会话期间有效,页面刷新或浏览器关闭则失效
            socket.set(name, data, [callback]);
        获取用户数据
            socket.get(name, callback);
    5.广播消息
        建立连接后,Socket.IO服务器具有一个sockets属性,属性值为所有与客户端建立连接的socket对象
        可以使用该对象的send/emit方法向所有客户端广播消息
    6.命名空间
        在一个特定的应用程序中完全控制消息与事件的发送,只需要使用一个默认的"/"命名空间就足够了
        如果需要将应用程序作为第三方服务提供给其他应用程序
        那么需要为一个用于与客户端连接的socket端口定义一个独立的命名空间        
16.综合案例
    1.创建简单聊天室应用程序
        1.概述
            使用Express框架与Socket.IO类库创建一个简单聊天室
            当用户访问聊天室应用程序,浏览器显示一个页面
            用户输入用户名然后登陆,与其他已经登陆聊天室的用户聊天
            页面还有个用户列表,实时更新,显示当前还在的用户
        2.效果
            显示欢迎用户加入的消息,同时追加用户名到用户列表
            在会话框输入内容,发送,内容被广播到所有登录到Socket.IO聊天室中的用户
            当用户退出的时候,显示用户退出,同时从用户列表删除
        3.HTML/CSS代码
        4.JS代码
        5.服务器端代码
    2.创建web应用程序
        1.概述
            使用Express框架、MongoDB数据库、Mongoose数据库制作一个web应用程序
            实现对商业订单进行增删改查及修改
            显示两个页面:
                1.第一个页面为检索页面,在该页面执行在MongoDB数据库中检索订单数据的功能
                    检索出订单,出现在下方,点击编辑按钮进入编辑页面
                2.第二个页面为订单编辑页面            