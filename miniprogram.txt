1.小程序
    1.小程序分装的很好,比较简单
        1.支付
        2.云开发
    2.跨端
        1.支付宝小程序
        2.头条
        3.百度小程序
        4.taro React
        5.uni-app Vue
    3.项目
2.测试
    1.自动化测试
    2.大厂视野
3.算法和数据结构
4.设计模式
5.性能优化
    1.React ssr
    2.百度是怎么上线前端代码的
    3.文件加载
    4.文件执行
6.面试
##配置小程序
    1.开发需求被规定在配置文件中
    2.保证开发出来的小程序风格一致
        app.json:全局配置
        page.json:页面配置
        project.config.json:项目配置文件
        sitemap.json:微信检索,会被关键字检索出来
##所有页面必须在json中注册才能使用
##双线程模型
    宿主环境:微信客户端
        为了执行小程序的各种文件:wxml,wxss,js
        提供了小程序的双线程模型
    整体上开了两个线程:
        1.渲染层:webview
            wxml,wxss
            多页面使用多个webview的线程
        2.逻辑层:jscore
            js
    都经由微信客户端native进行中转交互
    首先转化成js对象,再生成一棵DOM树
    数据变化,生成一棵新的DOM树,通过diff算法来对比变化的部位
    然后将差异应用到原来的DOM树上
##小程序启动流程
    1.下载小程序包
    2.启动小程序
    3.加载app.json
    4.注册App()
        执行App生命周期
    5.加载自定义组件代码注册自定义组件
        加载解析page.json
        渲染层加载渲染page.wxml
        逻辑层注册Page()
            执行Page生命周期
##注册App
##组件
    1.text组件
        显示文本,类似span标签,行内元素
            selectable:"{{false}}"是否可选中
            space
            decode
    2.button组件
    3.view组件
        类似div,块级元素,独占一行,容器
##隐藏 
    hidden:组件依然存在
    wx-if:组件不存在,压根没有创建
##block标签
##key:提高性能,绑定一个id,对相同的进行复用,高效的更新虚拟DOM
    diff算法,在需要插入时依次改变
    key给每个节点做一个唯一标识,用于diff正确识别节点
##模板
    template 代码复用
##wxs模块
    小程序的一套脚本语言,结合wxml可以构建页面的结构
    与js是不同的语言,有自己的语法,不和js一致(基本一致)
    与js代码是隔离的,不能调用js中定义的函数以及小程序提供的API
    不能作为组件的事件回调
    在ios上会比js快很多,安卓上午差异
##事件对象
    某个事件触发,就会产生一个事件对象,并将这个对象传入到回调函数中
    touches:记录当前有几个手指在小程序中触摸以及触摸点的信息
    changedTouches:只是记录变化的
    currentTarget:触发事件的
    target:产生事件的
    事件的传递参数:
##事件冒泡和事件捕获
    往外冒泡,往里捕获
##组件化开发
    组件和页面通信
    数据:properties
    样式:externalClasses
    标签:slot
##项目结构
    1.目录的结构
        1.pages:页面
        2.components:公共组件包
        3.assets:资源图片图标
        4.service:网络请求      
        5.utils:工具相关的东西
    2.项目页面结构
        根据tabbar来划分页面
    3.组件化
    4.商品数据显示
        1.数据模型的设计
            goods:{
                'pop': {page:0, list:[]},
                'mew': {page:0, list:[]},
                'sell': {page:0, list:[]}
            }
        2.发送网络请求,将数据存储起来
            
        3.

