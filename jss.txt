##读书笔记
    1.get请求传参长度的误区
        误区:我们常说,get请求参数大小存在限制,post请求的参数无限制
        实际上,HTTP协议从未规定GET/POST的请求长度限制是多少
        GET的最大长度显示是因为浏览器和web服务器限制了URL的长度
    2.get/post请求在缓存方面的区别
        get请求类似于查找的一个过程,用户获取数据,可以不用每次都和数据库建立连接,可以使用缓存
        post一般是修改删除操作,必须和数据库进行交互,不能使用缓存,get更适合请求缓存
    6.前端的事件流
        HTML和JS交互是靠事件驱动来实现的,例如鼠标点击事件,页面滚动事件等
        向文档或者文档中的元素添加事件侦听器来预订事件
        想要知道事件在什么时候进行调用,需要知道"事件流"
        1.事件流:描述从网页接受事件的顺序
            1.事件捕获阶段
            2.处于目标阶段
            3.事件冒泡阶段
        2.addEventListener:事件处理程序的操作
            三个参数:
                1.处理事件名
                2.作为事件处理程序的一个函数
                3.一个布尔值
                    布尔值为true则在捕获阶段调用事件处理程序
                    布尔值为false则在冒泡阶段调用事件处理程序
    7.如何让事件先冒泡后捕获
        在DOM标准事件模型中,是先捕获后冒泡
        对于同一个事件,监听捕获和冒泡,分别对应相应的处理函数,监听到了捕获事件,先暂缓执行
        等到冒泡事件被捕获后再执行捕获事件
    8.事件委托
        不在事件的发生地(直接DOM)上设置监听函数,而是在其父元素上设置监听函数,通过事件冒泡
        父元素可以监听到子元素上事件的触发,最后通过事件发生元素DOM的类型来做出不同的反应
        比较适合动态元素绑定,新添加的子元素也可以拥有监听函数,也拥有了事件触发机制
    9.图片的懒加载和预加载
        1.预加载:提前加载,当用户需要查看时,直接从本地缓存中渲染,增加服务器前端压力
        2.懒加载:为服务器前端的优化,减少请求数或延迟请求数,迟缓甚至不加载
    10.mouseover/mouseenter的区别
        mouseover:当鼠标移入元素或者子元素都会触发事件,有一个重复触发、冒泡的过程:mouseout
        mouseenter:当鼠标移除元素本身(不包含元素的子元素)触发,不冒泡:mouseleave
    13.JS的各种位置
        1.clientHeight:表示可视区域的高度,不包括border和滚动条
        2.offsetHeight:表示可视区域的高度,包括了了border和滚动条
        3.scrollHeight:表示所有区域的高度,包括了因为滚动而被隐藏的部分
        4.clientTop:表示边框border的厚度,未指定一般为0
        5.scrollTop:滚动后被隐藏的高度
    14.js拖拽功能的实现
        首先是三个事件,mousedown、mousemove、mouseup
        当鼠标按下此时需要一个tag标识此时已按下,可以执行mousemove里的具体方法
        clientX、clientY是鼠标的坐标,分别标识横坐标和纵坐标
        offsetX、offsetY表示元素的初始坐标
        也可以使用HTML5的(Drag/drop)
    15.异步加载JS的方法
        默认情况下,脚本的执行是同步和阻塞的
            1.defer:只支持IE,如果你的脚本不会改变文档的内容,可将defer加入<script>标签中
              延迟脚本的执行,直到文档的载入和解析完成
            2.async:如果在IE中同时存在defer/async,那么defer的优先级更高
              尽快去执行脚本,而不是在下载脚本时阻塞文档解析
            3.创建script标签,插入到DOM中
    16.Ajax解决浏览器缓存问题
        1.在ajax发送请求前加上
            anyAjaxObj.setRequestHeader("If-Modified","0");
            anyAjaxObj.setRequestHeader("Cache-Control","no-cache");
          在URL后加上一个随机数和时间搓
            "fresh="+Math.random();
            "nowtime="+newDate().getTime();
        2.jQuery
            $.ajaxSetup({cache:false});
            这样所有ajax都会执行这条语句,不需要保存缓存记录
    17.JS的节流和防抖
        1.滚动优化
            滚动优化不仅仅指滚动事件(scroll事件),还包括resize这类频繁触发的事件
            var i = 0;
            window.addEventListener('scroll',function(){
                console.log(i++);
            },false);
            在绑定scroll、resize这类事件的时候,当它发生时,触发的频次非常高,间隔近,如果事件中涉及
            大量的位置计算、DOM操作、元素重绘等工作且这些工作无法在下一个scroll事件触发前完成,就会
            造成浏览器掉帧,而且鼠标滚动是连续的,就会持续触发scroll事件,掉帧继续扩大,浏览器CPU使用率
            增加,影响用户体验。
            在滚动事件中绑定回调应用场景也非常多,在图片的懒加载、侧边栏浮动导航栏等
            拥有平滑滚动是非常重要的
        2.滚动与页面渲染的关系
            一个web页面的展示:
                1.JS:一般来说,使用JS来实现一些视觉变化的效果,比如动画或添加DOM元素
                2.Style:计算样式,根据CSS选择器,对每一个DOM元素匹配相应的CSS样式,确定了样式规则
                3.Layout:布局,计算每一个DOM元素在屏幕上显示的大小和位置,布局是相对的,会联动其它元素布局
                4.Paint:绘制,就是一个填充像素的过程,也就是一个DOM元素的可视效果
                5.Composite:渲染层合并,对页面DOM元素的绘制是在多个层上进行的,每个层完成绘制之后,浏览器
                  会将所有的层按照合理的顺序合并成为一个图层,然后显示
            层概念,作为纹理传给GPU硬件加速
            一个网页生成,至少会渲染一次,用户访问过程中,会进行重排(reflow)和重绘(repaint)
            scroll和resize导致页面不断的重新渲染
            当你滚动页面时,浏览器会绘制这些层(合成层)里的一些像素,通过元素分组,当某个层的内容改变时
            只需要更新该层的结构,仅仅重绘变化的那一部分
        3.防抖和节流
            scroll事件会触发页面的重新渲染,scroll事件的handler也会被高频度的触发,handler内部不应该
            拥有复杂操作,例如DOM操作
            1.防抖
                把多个顺序的调用合并成为一次,也就是在一定时间内,规定事件被触发的次数
                //防抖动函数:如果500ms内没有连续触发两次scroll事件,就执行我们真正想触发的操作
                function debounce(func, wait, immediate){
                    var timeout;
                    return function(){
                        var context = this,args = arguments;
                        var later = function(){
                            timeout = null;
                            if(!immediate) func.apply(context, args);
                        };
                        var callNow = immediate && !timeout;
                        clearTimeout(timeout);
                        timeout = setTimeout(later, wait);
                        if (callNow) func.apply(context, args);
                    };
                };
                var myEfficientFn = debounce(function(){
                    //滚动中真正的操作
                },250);
                //绑定监听
                window.addEventListener('resize', myEfficientFn);
            2.节流
                防抖:类似于我停止下滑,图片被加载出来,希望可以一直不断加载,或者数据的ajax请求
                页面在不断的滚动,我们希望滚动handler可以以一定的频率触发
                //节流函数,只允许一个函数在x毫秒内执行一次
                function throttle(func, wait, mustRun){
                    var timeout,
                        startTime = new Date();
                    return function(){
                        var context = this,
                            args = arguments,
                            cyrTime = new Date();
                        clearTimeout(timeout);
                        //如果达到了规定的触发时间间隔,触发handler
                        if(curTime - startTime >= mustRun){
                            func.apply(context,args);
                            startTime = curTime;
                        //没有到触发间隔,重新设置定时器
                        }else{
                            timeout = setTimeout(func, wait);
                        }
                    };

                };
                function realFunc(){
                    console.log("Success");
                }
                window.addEventListener('scroll', throttle(realFunc, 500, 1000));
                如果一段时间scroll触发的间隔一直短于500ms,那么我们希望调用的handler会至少在
                1000ms内触发一次
        4.使用rAF触发滚动事件
    21.对象深度克隆的实现
        function deepClone(obj){
            var newObj = obj instanceof Array ? [] : {};
            for (var item in obj){
                var temple = typeof obj[item] == 'object' ? deepClone(obj[item]) : obj[item];
                newObj[item] = temple;
            }
            return newObj;
        }
        数组是对象但是和对象又有一定的区别
    22.JS监听对象属性的改变
        ES5:Object.defineProperty
        ES6:Proxy
    25.数组去重
        1.indexOf去重
        2.ES6中的Array.from(new Set(array))
    27.事件监听
    30.document.write和innerHTML的区别
        1.document.write
            直接写入页面的内容流,如果在写之前没有调用document.open
            浏览器会自动调用open,每次写完关闭之后重新调用该函数,导致页面被重写
        2.innerHTML
            DOM页面元素的一个属性,代表该元素的html内容
            可以精确到某一个具体的元素来进行更改
            比如要修改documen的内容
            document.documentElement.innerElement
            具体写入某个节点,不会导致页面全部重绘
    31.写出一个图片懒加载的实现步骤
        首先将img标签的链接设置为同一张图片(比如空白图片)
        然后给img标签设置自定义属性data-src
        将真正的图片地址存储在data-src
        当JS监听到该图片元素进入可视窗口,将自定义属性中的地址属性存储到src属性中       



