##读书笔记
    1.get请求传参长度的误区
        误区:我们常说,get请求参数大小存在限制,post请求的参数无限制
        实际上,HTTP协议从未规定GET/POST的请求长度限制是多少
        GET的最大长度显示是因为浏览器和web服务器限制了URL的长度
    2.get/post请求在缓存方面的区别
        get请求类似于查找的一个过程,用户获取数据,可以不用每次都和数据库建立连接,可以使用缓存
        post一般是修改删除操作,必须和数据库进行交互,不能使用缓存,get更适合请求缓存
    3.闭包
        1.定义:一个内部函数里，对在外部作用域(但不是全局作用域)的变量进行引用,那么内部函数就被认为是闭包
        2.闭包就是能够读取其他函数内部变量的函数,只有函数内部的子函数才能读取局部变量
          本质,闭包是函数内部和函数外部连接起来的桥梁
        3.特点
            1.可以读取自身函数外部的变量(沿着作用域链寻找)先从自身开始查找，如果自身没有才会继续往上级查找
              自身如果拥有将直接调用。(哪个离的最近就用哪一个)
            2.延长内部变量的生命周期
            3.函数b嵌套在函数a内部
            4.函数a返回函数b
        4.回收机制：
            在JavaScript中，如果一个对象不再被引用,那么这个对象就会被GC回收,如果俩个对象互相引用
            而不再被第3者所引用，那么这俩个互相引用的对象也会被回收。因为函数a被b引用，b又被a外的c引用
            这就是为什么函数a执行后不会被回收的原因
    4.类的创建和继承
    5.解决异步回调地狱
        promise、generator、async/await
    6.前端的事件流
        HTML和JS交互是靠事件驱动来实现的,例如鼠标点击事件,页面滚动事件等
        向文档或者文档中的元素添加事件侦听器来预订事件
        想要知道事件在什么时候进行调用,需要知道"事件流"
        1.事件流:描述从网页接受事件的顺序
            1.事件捕获阶段
            2.处于目标阶段
            3.事件冒泡阶段
        2.addEventListener:事件处理程序的操作
            三个参数:
                1.处理事件名
                2.作为事件处理程序的一个函数
                3.一个布尔值
                    布尔值为true则在捕获阶段调用事件处理程序
                    布尔值为false则在冒泡阶段调用事件处理程序
    7.如何让事件先冒泡后捕获
        在DOM标准事件模型中,是先捕获后冒泡
        对于同一个事件,监听捕获和冒泡,分别对应相应的处理函数,监听到了捕获事件,先暂缓执行
        等到冒泡事件被捕获后再执行捕获事件
    8.事件委托
        不在事件的发生地(直接DOM)上设置监听函数,而是在其父元素上设置监听函数,通过事件冒泡
        父元素可以监听到子元素上事件的触发,最后通过事件发生元素DOM的类型来做出不同的反应
        比较适合动态元素绑定,新添加的子元素也可以拥有监听函数,也拥有了事件触发机制
    9.图片的懒加载和预加载
        1.预加载:提前加载,当用户需要查看时,直接从本地缓存中渲染,增加服务器前端压力
        2.懒加载:为服务器前端的优化,减少请求数或延迟请求数,迟缓甚至不加载
    10.mouseover/mouseenter的区别
        mouseover:当鼠标移入元素或者子元素都会触发事件,有一个重复触发、冒泡的过程:mouseout
        mouseenter:当鼠标移除元素本身(不包含元素的子元素)触发,不冒泡:mouseleave
    11.js的new操作符做了哪些
        新建了一个空对象,这个对象原型指向构造函数的prototype,执行构造函数后返回这个对象
    12.改变函数内部this指针的指向函数(bind/call/apply的区别)
        通过apply和call改变函数的this指向,第一个参数都是表示要改变指向的那个对象
        第二个参数apply是数组,call是arg1,arg2...这种形式
        bind改变this作用域会返回一个新的函数,这个函数也不会立马执行
    13.JS的各种位置
        1.clientHeight:表示可视区域的高度,不包括border和滚动条
        2.offsetHeight:表示可视区域的高度,包括了了border和滚动条
        3.scrollHeight:表示所有区域的高度,包括了因为滚动而被隐藏的部分
        4.clientTop:表示边框border的厚度,未指定一般为0
        5.scrollTop:滚动后被隐藏的高度
    14.js拖拽功能的实现
        首先是三个事件,mousedown、mousemove、mouseup
        当鼠标按下此时需要一个tag标识此时已按下,可以执行mousemove里的具体方法
        clientX、clientY是鼠标的坐标,分别标识横坐标和纵坐标
        offsetX、offsetY表示元素的初始坐标
        也可以使用HTML5的(Drag/drop)
    15.异步加载JS的方法
        默认情况下,脚本的执行是同步和阻塞的
            1.defer:只支持IE,如果你的脚本不会改变文档的内容,可将defer加入<script>标签中
              延迟脚本的执行,直到文档的载入和解析完成
            2.async:如果在IE中同时存在defer/async,那么defer的优先级更高
              尽快去执行脚本,而不是在下载脚本时阻塞文档解析
            3.创建script标签,插入到DOM中
    16.Ajax解决浏览器缓存问题
        1.在ajax发送请求前加上
            anyAjaxObj.setRequestHeader("If-Modified","0");
            anyAjaxObj.setRequestHeader("Cache-Control","no-cache");
          在URL后加上一个随机数和时间搓
            "fresh="+Math.random();
            "nowtime="+newDate().getTime();
        2.jQuery
            $.ajaxSetup({cache:false});
            这样所有ajax都会执行这条语句,不需要保存缓存记录
    17.JS的节流和防抖
        1.滚动优化
            滚动优化不仅仅指滚动事件(scroll事件),还包括resize这类频繁触发的事件
            var i = 0;
            window.addEventListener('scroll',function(){
                console.log(i++);
            },false);
            在绑定scroll、resize这类事件的时候,当它发生时,触发的频次非常高,间隔近,如果事件中涉及
            大量的位置计算、DOM操作、元素重绘等工作且这些工作无法在下一个scroll事件触发前完成,就会
            造成浏览器掉帧,而且鼠标滚动是连续的,就会持续触发scroll事件,掉帧继续扩大,浏览器CPU使用率
            增加,影响用户体验。
            在滚动事件中绑定回调应用场景也非常多,在图片的懒加载、侧边栏浮动导航栏等
            拥有平滑滚动是非常重要的
        2.滚动与页面渲染的关系
            一个web页面的展示:
                1.JS:一般来说,使用JS来实现一些视觉变化的效果,比如动画或添加DOM元素
                2.Style:计算样式,根据CSS选择器,对每一个DOM元素匹配相应的CSS样式,确定了样式规则
                3.Layout:布局,计算每一个DOM元素在屏幕上显示的大小和位置,布局是相对的,会联动其它元素布局
                4.Paint:绘制,就是一个填充像素的过程,也就是一个DOM元素的可视效果
                5.Composite:渲染层合并,对页面DOM元素的绘制是在多个层上进行的,每个层完成绘制之后,浏览器
                  会将所有的层按照合理的顺序合并成为一个图层,然后显示
            层概念,作为纹理传给GPU硬件加速
            一个网页生成,至少会渲染一次,用户访问过程中,会进行重排(reflow)和重绘(repaint)
            scroll和resize导致页面不断的重新渲染
            当你滚动页面时,浏览器会绘制这些层(合成层)里的一些像素,通过元素分组,当某个层的内容改变时
            只需要更新该层的结构,仅仅重绘变化的那一部分
        3.防抖和节流
            scroll事件会触发页面的重新渲染,scroll事件的handler也会被高频度的触发,handler内部不应该
            拥有复杂操作,例如DOM操作
            1.防抖
                把多个顺序的调用合并成为一次,也就是在一定时间内,规定事件被触发的次数
                //防抖动函数:如果500ms内没有连续触发两次scroll事件,就执行我们真正想触发的操作
                function debounce(func, wait, immediate){
                    var timeout;
                    return function(){
                        var context = this,args = arguments;
                        var later = function(){
                            timeout = null;
                            if(!immediate) func.apply(context, args);
                        };
                        var callNow = immediate && !timeout;
                        clearTimeout(timeout);
                        timeout = setTimeout(later, wait);
                        if (callNow) func.apply(context, args);
                    };
                };
                var myEfficientFn = debounce(function(){
                    //滚动中真正的操作
                },250);
                //绑定监听
                window.addEventListener('resize', myEfficientFn);
            2.节流
                防抖:类似于我停止下滑,图片被加载出来,希望可以一直不断加载,或者数据的ajax请求
                页面在不断的滚动,我们希望滚动handler可以以一定的频率触发
                //节流函数,只允许一个函数在x毫秒内执行一次
                function throttle(func, wait, mustRun){
                    var timeout,
                        startTime = new Date();
                    return function(){
                        var context = this,
                            args = arguments,
                            cyrTime = new Date();
                        clearTimeout(timeout);
                        //如果达到了规定的触发时间间隔,触发handler
                        if(curTime - startTime >= mustRun){
                            func.apply(context,args);
                            startTime = curTime;
                        //没有到触发间隔,重新设置定时器
                        }else{
                            timeout = setTimeout(func, wait);
                        }
                    };

                };
                function realFunc(){
                    console.log("Success");
                }
                window.addEventListener('scroll', throttle(realFunc, 500, 1000));
                如果一段时间scroll触发的间隔一直短于500ms,那么我们希望调用的handler会至少在
                1000ms内触发一次
        4.使用rAF触发滚动事件
    18.JS垃圾回收机制
        1.必要性
            JS每次创建字符串、数组或对象,都必须分配内存来存储这个实体,动态分配内存,最终需要释放掉这些内存
            否则内存都会被消耗完,JS检测何时不再需要使用一个对象了,就将它的内存释放掉
        2.垃圾回收方法
            1.标记清除
                最常见的一种方法,变量进入环境,标记为"进入环境",永远不能释放进入环境的变量所占的内存
                离开就标记为离开环境
                垃圾回收器会给存储在内存中的变量都加上标记,然后去除环境变量中的变量,以及被环境中的变量
                所引用的变量的标记,然后删除所有被标记的变量,删除的变量无法在环境变量中被访问,回收内存
            2.引用计数法
                每个值没有引用的次数,当声明了一个变量,并用一个引用类型的值赋值给改变量,则这个值的引用
                次数就是1,相反的,如果包含了对这个值的引用的变量又取得了另一个值,那么原先的引用值的引用
                次数就减一,当引用次数为0时,就没办法访问这个值了,就会被回收内存
                缺点:；两个对象互相引用,导致内存泄漏
    19.前端模块化
        将复杂的文件编程一个一个独立的模块,比如js文件,分成独立的模块有利于重用和维护
        但会带来模块之间相互依赖的问题,所以又有了commonJS规范,AMD,CMD规范
        以及JS打包(编译等处理)的工具webpack
    20.Commonjs、AMD、CMD
        一个模块就是实现特定功能的文件,想加载什么功能就加载什么模块
        1.Commonjs:开始于服务器端的模块化,同步定义的模块化,每个模块都是一个单独的作用域,模块输出
          modules.exports,模块加载require()引入模块
        2.AMD:中文名异步模块定义
          requireJS实现了AMD规范,主要解决以下两个问题
            1.多个文件有依赖关系,被依赖文件需要早于依赖它的文件加载到浏览器
            2.加载的时候浏览器停止渲染,加载文件越多,页面失去响应的事件越长
            语法:requireJS定义了一个函数define,它是一个全局变量,用来定义模块
                define(['dependency'], function(){
                    var name = 'Byron';
                    function printName(){
                        console.log(name);
                    }
                    return {
                        printName: printName
                    };
                });
            //加载模块
                require(['myModule'], function (my){
                    my.printName();
                })
    21.对象深度克隆的实现
        function deepClone(obj){
            var newObj = obj instanceof Array ? [] : {};
            for (var item in obj){
                var temple = typeof obj[item] == 'object' ? deepClone(obj[item]) : obj[item];
                newObj[item] = temple;
            }
            return newObj;
        }
        数组是对象但是和对象又有一定的区别
    22.JS监听对象属性的改变
        ES5:Object.defineProperty
        ES6:Proxy
    23.理解定时器
        定时器是JS动画的核心技术
        1.setTimeout()
            用来指定某个函数或字符串在指定的毫秒数之后执行,也可以用clearTimeout()取消
    24.this机制
        1.默认绑定
            全局环境中this默认绑定到window
            函数独立调用也默认绑定到window
            被嵌套的函数独立调用时,也绑定到window
        2.隐式绑定
            被直接对象所包含的函数调用时,也称为方法调用,this隐式绑定到该直接对象
        3.new绑定
            函数或者方法调用前带有关键字mew,构成构造函数调用,称为new绑定
    25.数组去重
        1.indexOf去重
        2.ES6中的Array.from(new Set(array))
    26.JS实现跨域
        1.什么是跨域
            协议，域名，端口，其中一个不一样，就代表跨域
            不是一个源的文档无法操作另一个源的文档，受限如下：
                1.Cookie、LocalStorage和IndexDB无法读取
                2.DOM无法获得
                3.AJAX请求不能发送
            可以跨域加载资源的三个标签
                1.img-src（图片提供方也可以做下防止盗用链接的处理)
                2.link- href  可以使用CDN
                3.script-src 可以使用CDN，也可以用用于JSONP
        2.解决方案：
            1.前端：
                1.jsonp
                2.Hash
                3.postMessage（H5新增的）
                4.WebSocket（不受同源策略限制）
                5.CORS（支持跨域通信的ajax，浏览器识别到ajax跨域后，会在http头中加一个origin允许跨域）
            2.服务端:
                设置http header
    27.事件监听
    28.JS基本数据类型
        undefined,null,string,boolean,number,symbol
    29.JS作用域链
        在JS引擎中,通过标识符查找标识符的值,会从当前作用域向上查找
        直到作用域找到第一个匹配的标识符位置
    30.document.write和innerHTML的区别
        1.document.write
            直接写入页面的内容流,如果在写之前没有调用document.open
            浏览器会自动调用open,每次写完关闭之后重新调用该函数,导致页面被重写
        2.innerHTML
            DOM页面元素的一个属性,代表该元素的html内容
            可以精确到某一个具体的元素来进行更改
            比如要修改documen的内容
            document.documentElement.innerElement
            具体写入某个节点,不会导致页面全部重绘
    31.写出一个图片懒加载的实现步骤
        首先将img标签的链接设置为同一张图片(比如空白图片)
        然后给img标签设置自定义属性data-src
        将真正的图片地址存储在data-src
        当JS监听到该图片元素进入可视窗口,将自定义属性中的地址属性存储到src属性中
    32.        



