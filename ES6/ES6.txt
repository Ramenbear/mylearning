##let和const命令
    1.let命令
        类似于var,let声明的变量只在let命令所在的代码块有效
        注意:var存在变量提升,但是只提升变量,相应的值并没有提升
        1.不存在变量提升
        2.暂时性死区
            使用let声明之前,该变量都是不可用的
        3.不允许重复声明
            在相同作用域不能重复声明同一个变量,不能在函数内部重新声明变量
    2.块级作用域
        1.let实际为JS新增了块级作用域
            外层代码块不受内层代码块的影响
            ES6规定在块级作用域之中,函数声明类似于let,在块级作用域之外不可引用
        2.do表达式
            在块级作用域之外没办法得到内层的值,加上do,成为do表达式,可以得到整个块级作用域的返回值
    3.const命令
        1.声明一个只读的常量,一旦声明,不能改变,同样也不能只声明而不赋值
            作用域和let一样,只在声明的块级作用域有效
        2.实际上不是值不能改变,而是变量指向的那个地址不得改动
    4.声明变量的方法:let var const import class function
        1.顶层对象的属性
            ES6规定var和function声明的全局变量依旧是顶层对象的属性
            let/const/class声明的全局变量不属于顶层对象的属性
        2.global对象
            引入global作为顶层对象,在所有环境下,global都是存在的,都可以拿到顶层对象
##变量的解构赋值
##字符串的扩展
    1.字符的Unicode表示法
        JS只限于码点在\u0000~\uFFFF之间的字符,超过就必须用2个双字节的形式表示
        ES6做出了改进,只要将码点放入大括号,就能正确解读该字符
    2.codePointAt()
        能够正确处理4个字节存储的字符,返回一个字符的码点
    3.String.fromCodePoint()
        可以识别大于0xFFFF的字符
    4.字符串的遍历器接口
        为字符串添加了遍历器接口,使得字符串可以由for...of循环遍历
    5.at()
        ES5提供charAt,返回字符串给定位置的字符
        ES6提供的at()可以识别大于0xFFFF的字符
    6.normalize()
        将字符的不同表示方法统一为同样的形式
    7.includes()、startsWith、endsWith
        传统上JS只有indexOf来确定一个字符串是否包含在另一个字符串中
        1.includes:返回布尔值,表示是否找到了参数字符串
        2.startsWith:返回布尔值,表示参数字符串是否在源字符串的头部
        3.endsWith:返回布尔值,表示参数字符串是否在源字符串的尾部
    8.repeat
        repeat:返回一个新字符串,表示将原字符串重复n次
    9.padStart()、padEnd()
        padStart():用于头部补齐
        padEnd():用于尾部补齐
        接受两个参数,第一个用来指定字符串的最小长度,第二个用来补全的字符串
    10.模板字符串
        模板字符串是增强版的字符串,用反引号(``)标识,可以当做普通字符串使用,也可以用来定义多行字符串
        或在字符串中嵌入变量
        1.可使用trim()方法消除换行,嵌入变量时,需要将变量名写在${}中
        2.模板字符串还能调用函数,或实现嵌套
            function fn(){
                return "Hello World";
            }
            `foo ${fn()} bar`
            // foo Hello World bar
    11.标签模板
        紧跟在一个函数名后面,该函数将被调用来处理这个模板字符串
        alert`123` //alert(123)
        其实不是模板,标签指函数,紧跟在其后的模板字符串就是它的参数
        应用:过滤HTML字符串,防止用户输入恶意内容
             多语言进行转换
    12.String.raw()
        充当模板字符串的处理函数,返回一个反斜线都被转义的字符串,对应于替换变量后的模板字符串
    13.模板字符串的限制
        放松限制,遇到不合法的的字符串转义,就返回undefined,而不是报错,并且从raw属性上可以得到原始字符串
##正则的扩展
    1.如果RegExp构造函数的第一个参数是一个正则对象,那么可以使用第二个参数指定修饰符,会覆盖原有的修饰符
    2.字符串对象共用四个方法可以使用正则表达式
        1.match()、replace()、search()、split()
    3.u修饰符,含义为"Unicode"模式,正确处理大于\uFFFF\的Unicode字符,可以处理四个字节
    4.点字符,除换行符以外的任意单个字符,对于码点大于0xFFFF的字符,必须加上u修饰符
    5.使用大括号表示Unicode字符的表示法,必须加上u修饰符
    6.有些字符的编码不同,但是字型相近,不加u就无法识别非规范的k字符
    7.y修饰符:粘连修饰符
        全局匹配,g只要剩余位置存在匹配,y会确保匹配必须从剩余的第一个位置开始
        使用sticky判断是否设置了y修饰符
    8.flags属性,会返回正则表达式的修饰符
        s修饰符,使得.可以匹配任意单个字符
        dotAll模式,返回一个布尔值,判断是否在dotAll模式下
    9.后行断言
        JS:支持先行断言和先行否定断言
            1.先行断言:x只有在y之前才匹配,必须写成/x(?=y)/
            2.先行否定断言:x只有不在y前面才匹配,/x(?!y)/
        ES6:后行断言和后行否定断言
    10.正则使用圆括号进行组匹配
        允许为每一个组匹配指定一个名字
##数值的扩展
    1.二进制和八进制表示法
        分别使用前缀:0b(0B)和0o(0O)表示
    2.Number.isFinite()、Number.isNaN()
        1.Number.isFinite():检查是否有限
        2.Number.isNaN()：检查是否为NaN
    3.ES6将全局方法移植到了Number.parseInt()、Number.parseFloat()
    4.Number.isInteger()判断是否为整数
    5.Number.EPSILON():误差小于这个就认为正确了
    6.JS整数有范围,Number.isSafeInteger()判断是否在这个范围内
    7.Math对象的扩展
        1.Math.trunc():去除小数部分,返回整数部分
        2.Math.sign():判断数到底是正是负或0
        3.Math.cbrt():计算立方根
        4.Math.clz32():返回一个整数的32位无符号整数形式有多少个前导0
        5.Math.imul():返回两个数以32位带符号整数形式相乘的结果
        6.Math.fround():返回一个数的单精度浮点数形式
        7.Math.hypot():返回所有参数的平方和的平方根
        8.Math.expm1():
        9.Math.log1p():
        10.Math.log10():
        11.Math.log2():
        12.新增6个双曲函数方法
        13.Math.signbit():判断符号位是否设置
        14.指数运算符:**
        15.数据类型:Integer无位数限制
##函数的扩展
    1.函数参数默认值
        1.允许为函数参数设置默认值,直接跟在参数定义的后面
        2.参数默认值可以和解构赋值结合起来使用
        3.默认值应该是函数的尾函数
    2.函数的length属性
        定义了默认值后,函数的length将失真
    3.作用域
        一旦设置了参数默认值,进行声明初始化的时候,参数会形成一个单独的作用域
    4.rest参数
        用于获取多余参数,不需要使用arguments对象,搭配的是一个数组,其后不再有其他参数
    5.严格模式
        ES6规定使用了默认值、解构赋值、扩展运算符,那么就不能使用严格模式,否则就会报错
    6.name属性
        返回该函数的函数名,匿名函数,ES6会返回实际的函数名
    7.箭头函数
        1.ES6允许使用=>定义函数
            var f = v => v;
            var f = function(v){
                return v;
            }
        2.注意事项
            1.函数体内的this对象就是定义时所在的对象,而不是使用时所在的对象,固定的
            2.不可以当做构造函数,也就是不可以使用new命令
            3.不可以使用arguments对象,可以使用rest代替
            4.不可以使用yield命令,箭头函数不可以用作Genertor
        3.this指向固定化:箭头函数没有自己的this,内部的this就是外层代码块的this,所以不能用作构造函数
        4.箭头函数可以嵌套
        8.绑定this
            1.函数绑定运算符(::),左边是一个对象,右边是一个函数
                自动将左边的对象作为上下文环境(即this对象)绑定到右边的函数上
                foo::bar;
                bar.bind(foo);
            2.如果双冒号左边为空,右边是一个对象的方法,则等于将该方法绑定到该对象
            3.由于双冒号返回的还是原对象,可以使用链式写法
    8.尾调用
        就是某个函数最后一步是调用另一个函数
    9.尾调用优化
        函数调用会在内部形成一个"调用记录",又称为"调用帧",保存调用位置和内部变量等信息
        如果在函数A的内部调用函数B,那么在A的调用帧上方还会形成一个B的调用帧,等到B运行结
        束,将结果返回到A,B的调用帧才会消失,如果B后还有一个C,一次类推,形成一个"调用栈"
        优化:只保留内层函数的调用帧
    10.尾递归
        尾调用自己
        递归非常耗费内存,因为要保存成千上万个调用帧,出现"栈溢出"错误
        尾递归只保存一个调用栈,不会出现"栈溢出"现象
    11.尾递归优化只有在严格模式下才开启
    12.自己定义实现尾递归优化,使用"循环"替换"递归"
    13.ES7提出允许函数最后一个参数有尾逗号
##数组的扩展
    1.扩展运算符
        1.(...)将一个数组转为用逗号分隔的参数序列
        2.替代数组的apply方法
            apply方法可以将数组转化为函数的参数
            扩展运算符可以展开数组,不需要使用apply方法了
        3.应用
            1.合并数组
            2.与解构赋值一起使用
            3.函数的返回值,JS函数只能返回一个值,扩展运算符可以返回多个值,数组或对象
            4.可以将字符串转为真正的数组
            5.任何Iterator对象都可以用扩展运算符转为真正的数组
    2.Array.from()
        将两类对象转为真正的数组,类似数组的对象和可遍历的对象
    3.Array.of()
        将一组值转换成数组
    4.copyWithin()
        将指定成员复制到其他位置,返回当前数组,会改变数组
    5.find:找出第一个符合条件的数组成员
      findIndex:返回第一个符合条件的数组成员的位置
    6.fill:使用给定值来填充一个数组
    7.遍历数组:返回一个遍历器对象
        1.keys():键名的遍历
        2.values():键值的遍历
        3.entries():键值对的遍历
    8.includes:数组是否包含给定的值
    9.数组的空位:空位是没有任何值,undefined是有值的
        ES6明确将空位转为undefined
##对象的扩展
    1.属性的简洁表示法
        ES6允许在对象中只写属性名,这时,属性值等于属性名所代表的变量
    2.属性名表达式
        用表达式作为属性名,将表达式放入方括号内
    3.方法的name属性
        返回函数名
    4.Object.is()
        判断是否严格相等+0 != -0 NaN === NaN
    5.Object.assign()
        将源对象的所有可枚举属性复制到目标对象
        第一个为目标对象,其后为源对象,浅复制
    6.属性的可枚举性
        对象的每个属性都有一个描述对象,用于控制该属性的行为
        获取属性的描述对象:Object.getOwnPropertyDescriptor
    7.属性的遍历
        1.for...in
            返回自身的和可继承的可枚举属性(不含Symbol)
        2.Object.keys(obj)
            返回一个数组,包括自身的(不含继承的)所有可枚举属性(不含Symbol)
        3.Object.getOwnPropertyNames(obj)
            返回所有属性(不含Symbol)
        4.Object.getOwnPropertySymbols(obj)
            返回一个数组包含Symbol属性
        5.Reflect.ownKeys(obj)
            返回所有属性
    8.额外属性
        1.__proto__
            设置当前对象的prototype对象
        2.Object.setPrototypeOf()
            设置当前对象的prototype对象,返回参数本身
            ES6正式推荐的设置原型对象
        3.Object.getPrototypeOf()
            读取一个对象的prototype对象
    9.对象的扩展运算符
    10.Null传导运算符(?.)
        const firstName = message?.body?.user?.firstName || 'default'
        只要其中返回一个null/undefined,就不再继续
##Set/Map数据结构
    1.Set
        1.基本用法
            类似于数组,成员值是唯一的,没有重复
        2.属性和方法
            1.属性
                构造函数,默认就是Set函数
                size:实例的成员个数
            2.方法
                1.操作
                    add(value)
                    delete(value)
                    has(value)
                    clear()
                2.遍历
                    keys()
                    values()
                    entries()
                    forEach()
                前三者返回遍历器对象,木有键名,只有键值
        3.应用
            1.扩展运算符和Set结构相结合去除数组的重复成员
                let unique = [...new Set(arr)];
            2.数组的map/filter也可以作用于Set
            3.遍历中改变原来Set结构
                1.映射一个新的结构,然后赋值给原来的Set结构
                2.使用Array.from方法
    2.WeakSet
        1.其中的成员只能是对象
        2.弱引用,不被垃圾回收所考虑
    3.Map
        JS对象本质是键值对的集合,只能用字符串作为键,带来了很大的限制
        Map类似于对象,但是键不限于字符串,各种类型的值都可以用来当作键
        1.属性和方法
            1.方法
                1.操作
                    size
                    set(key,value)
                    get(key)
                    delete(key)
                    has(key)
                    clear()
                2.遍历
                    keys()
                    values()
                    entries()
                    forEach()
        2.与其他数据结构进行转换
    4.WeakMap
        1.只接受对象作为键名,不接受其他类型的值
        2.键名所指向的对象不计入垃圾回收机制
        3.应用场景
            一旦不需要就会自动消失,不需要手动去删除
            在网页的DOM元素上添加数据就可以使用,当DOM元素被删除,相应的WeakMap也就被自动移除
##Reflect
    1.概述
        Reflect对象和Proxy对象都是为了操作对象提供的API
    2.设计目的
        1.将Object对象的一些明显属于语言内部的方法放到Reflect对象上,现阶段,某些方法同时在Object对象和
          Reflect对象上部署,未来的新方法只在Reflect对象上部署,可以直接获取语言内部的方法
        2.修改某些方法返回的结果,让其变得更加合理
        3.让Object操作都变成函数行为
        4.Reflect对象和Proxy对象方法一一对应,Proxy对象可以方便调用对应的Reflect方法来完成默认行为
          也就是说无论Proxy怎么修改默认行为,我们总可以在Reflect上获取默认行为
##JS异步机制(方便更好地理解Promise对象)
    3.单线程和多线程
        JS是单线程，怎么还存在异步，耗时操作到底交给谁去执行了？
        JS是一门语言，说是单线程还是多线程得结合具体运行环境。
        JS的运行通常是在浏览器中进行的，具体由JS引擎去解析和运行
    4.浏览器
        1.浏览器内部是多线程的
        2.常见线程
            1.渲染引擎线程：顾名思义，该线程负责页面的渲染
            2.JS引擎线程：负责JS的解析和执行
            3.定时触发器线程：处理定时事件，比如setTimeout, setInterval
            4.事件触发线程：处理DOM事件
            5.异步http请求线程：处理http请求
        3.渲染线程和JS引擎线程是不能同时进行的。渲染线程在执行任务的时候，
          JS引擎线程会被挂起。因为JS可以操作DOM，若在渲染中JS处理了DOM，浏览器就不知所措了
    5.渲染引擎和JS引擎
        渲染引擎就是如何渲染页面，Chrome用Webkit引擎，IE用Trident引擎，FireFox用Gecko引擎
        不同的引擎对同一个样式的实现不一致，就导致了浏览器样式兼容性问题
        1.JS引擎
            JS引擎可以说是JS虚拟机，负责JS代码的解析和执行
                1.词法分析：将源代码分解为有意义的分词
                2.语法分析：用语法分析器将分词解析成语法树
                3.代码生成：生成机器能运行的代码
                4.代码执行
            不同浏览器的JS引擎也不同，Chrome用的是V8，FireFox用的是SpiderMonkey
            Safari用的是JavaScriptCore，IE用的是Chakra
        2.JS是单线程，浏览器在运行时只开启了一个JS引擎线程来解析和执行JS
          如果同时有两个线程去操作DOM，浏览器要不知所措
          虽然JS是单线程的，可是浏览器内部不是单线程的。一些I/O操作、定时器的计时和事件监听
          （click, keydown…）等都是由浏览器提供的其他线程来完成的
    6.消息队列和事件循环
        1.回调函数具体何时加入到JS引擎线程中执行？
            1.左边的栈存储的是同步任务，就是那些能立即执行、不耗时的任务，如变量和函数的初始化
              事件的绑定等等那些不需要回调函数的操作
            2.右边的堆用来存储声明的变量、对象。下面的队列就是消息队列，一旦某个异步任务有了响应
              就会被推入队列中。如用户的点击事件、浏览器收到服务的响应和setTimeout中待执行的事件，
              每个异步任务都和回调函数相关联
            3.JS引擎线程用来执行栈中的同步任务，当所有同步任务执行完毕后，栈被清空
             然后读取消息队列中的一个待处理任务，并把相关回调函数压入栈中，单线程开始执行新的同步任务
             JS引擎线程从消息队列中读取任务是不断循环的，每次栈被清空后，都会在消息队列中读取新的任务
             等待新的任务出现,这就叫事件循环
    7.setTimeout
        1.间隔一定的时间后，将回调函数插入消息队列中，等栈中的同步任务都执行完毕后，再执行。
          因为栈中的同步任务也会耗时，所以间隔的时间一般会大于等于指定的时间
        2.setTimeout(fn, 0)的意思是，将回调函数fn立刻插入消息队列，等待执行，而不是立即执行
##Promise对象
    2.简单来说就是一个容器,保存着某个未来才会结束的事件,一个异步操作的结束
    3.三种状态:Pending(进行中) Fulfilled(已成功) Rejected(已失败)
    4.是一个构造函数用来生成Promise实例
        1.Promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法
          原型上有then、catch等同样很眼熟的方法。这么说用Promise new出来的对象
        2.肯定就有then、catch方法,可以new一个
            var p = new Promise(function(resolve, reject){
                //做一些异步操作
                    setTimeout(function(){
                    console.log('执行完成');
                    resolve('数据');
                }, 2000);
            });
        Promise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject
        分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数
        按照标准来讲，resolve是将Promise的状态置为fullfiled,reject是将Promise的状态置为rejected
        在上面的代码中，我们执行了一个异步操作，也就是setTimeout，2秒后，输出“执行完成”，
        并且调用resolve方法,运行代码，会在2秒后输出“执行完成”,只是new了一个对象,并没有调用它
        3.这是需要注意,所以我们用Promise的时候一般是包在一个函数中，在需要的时候去运行这个函数
        function runAsync(){
            var p = new Promise(function(resolve, reject){
                //做一些异步操作
                    setTimeout(function(){
                        console.log('执行完成');
                        resolve('数据');
                    }, 2000);
            });
            return p;            
        }
        runAsync()
        runAsync().then(function(data){
            console.log(data);
            //用传过来的数据做些其他操作
            //......
        });
        在我们包装好的函数最后，会return出Promise对象,执行这个函数我们得到了一个Promise对象
        在runAsync()的返回上直接调用then方法，then接收一个参数函数，并且会拿到我们在runAsync中调用
        resolve时传的的参数。会在2秒后输出“执行完成”，紧接着输出“数据”
        原来then里面的函数就跟我们平时的回调函数一个意思，能够在runAsync这个异步任务执行
        完成之后被执行。这就是Promise的作用了就是能把原来的回调写法分离出来，在异步操作执行完后
        用链式调用的方式执行回调函数
        4.Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用
          它比传递callback函数要简单、灵活的多
            runAsync1()
            .then(function(data){
                console.log(data);
                return runAsync2();
            })
            .then(function(data){
                console.log(data);
                return runAsync3();
            })
            .then(function(data){
                console.log(data);
            });
        5.function getNumber(){
            var p = new Promise(function(resolve, reject){
                //做一些异步操作
                setTimeout(function(){
                    var num = Math.ceil(Math.random()*10); 
                    if(num<=5){
                        resolve(num);
                    }
                    else{
                        reject('大了');
                    }
                }, 2000);
            });
            return p;            
            }
            getNumber()
            .then(
                function(data){
                    console.log('resolved');
                    console.log(data);
            }, 
                function(reason, data){
                    console.log('rejected');
                    console.log(reason);
                }
            );
            “失败”的情况，reject的作用就是把Promise的状态置为rejected，这样我们在then中就能捕捉到
            然后执行“失败”情况的回调
        6.还有一个catch方法，其实它和then的第二个参数一样，用来指定reject的回调
        7.Promise的all方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调
        8.all方法的效果实际上是谁跑的慢，以谁为准执行回调，那么相对的就有另一个方法
          谁跑的快，以谁为准执行回调，这就是race方法
##Iterator
    1.Iterator遍历器
        它是一个接口,为各种不同的数据结构提供统一的访问机制
        任何数据结构,只要部署Iterator接口,就可以完成遍历操作
    2.作用域
        1.为各种数据结构提供一个统一的、简便的访问接口
        2.使得数据结构的成员可以按某种次序排序
        3.ES6创建了新的遍历命令:for...of循环
    3.遍历过程
        1.创建指针对象,指向当前数据结构的起始位置,遍历器对象本质是一个指针对象
        2.第一次调用指针对象的next方法,指向数据结构的第一个成员
        3.第二次调用,指向第二个成员
        4.不断调用,直到结束
    4.返回
        返回一个遍历器对象,拥有两个属性
        1.value:当前位置的成员
        2.done:一个布尔值,表示遍历是否结束
    5.默认Iterator接口
        数据结构只要部署了Iterator接口,我们就称其为可遍历的
        ES6规定,默认的Iterator接口部署在数据接口的Symbol.iterator属性
    6.原生的具备Iterator接口
        Array Map Set String TypedArray 函数的argumemnts对象 NodeList对象
    7.调用Iterator接口的场合
        1.解构赋值
        2.扩展运算符
        3.yield*
##Generator函数
    1.ES6提供的异步编程解决方案,是Iterator接口的具体实现
    2.执行Generator函数会返回一个遍历器对象,Generator函数除了状态机,还是一个遍历器对象生成函数。
      返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。
    3.Generator函数是一个普通函数，但是有两个特征：
      Function关键字与函数名之间有一个*
      函数体内部使用yield语句，定义不同的内部状态(yield意思产出)
    4.Generator函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号，不同的是，
      调用Generator函数后，该函数并不执行，返回的也不是函数运行的结果，而是一个指向内部状态的指针对象
      下一步必须调用遍历器对象的next方法，使得指针移向下一个状态。Generator函数是分段执行的
      yield语句是暂停执行的标记，而next方法可以恢复执行。
    5.可以在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为
    6.Generator和协程
        1.协程是一种程序运行的方式,可以理解成"协作的线程"
            子例程:协程单线程实现
            特殊的线程:多线程实现
        2.协程与子例程的差异
            1.子例程
                堆栈式"后进先出",只有当调用的子函数完全执行完成,才会结束执行父函数
            2.协程
                多个线程可以并行执行,但只有一个线程处在正在运行状态,其他线程处于暂停态
                线程之间可以交换执行权,并行执行、交换执行权的线程称为协程
            3.普通线程
                抢占式,到底哪个线程先得到资源,必须由运行环境决定
            4.JS是单线程语言,只能保持一个调用栈,引入协程后,每个任务可以保持自己的调用栈
                抛出错误,可以找到原始的调用栈,不像异步操作的回调函数一旦出错,原始调用栈早就结束
            5.完全协程:任何函数都可以让暂停的协程继续执行
              半协程:只有Generator函数的调用者才能转移程序的执行权    
    7.应用：
        1.异步操作的同步化表达
        2.多步操作，依次执行
        3.部署Iterator接口
        4.作为数据结构
##Generator函数的异步应用
    1.异步编程对Javascript太重要，Javascript语言执行环境是单线程的，如果没有异步编程，
      根本没法用，非卡死不可
    2.ES6之前,异步编程
        1.回调函数
        2.事件监听
        3.发布/订阅
        4.Promise对象
    3.异步
        向操作系统发出请求,等待操作系统返回文件后再接着执行任务的第二段
    4.回调函数
        JS异步编程的实现就是回调函数,指把任务的第二段单独写在一个函数里面,等到重新执行这个任务的时候
        便直接调用函数:callback
            fs.readFile('/etc/passwd', 'utf-8', function(err, data){
                if (err) throw err;
                console.log(data);
            });
        执行分为两段,第一段完成以后,任务所在的上下文环境就已经结束了,在这之后跑出的错误
        在原来的上下文环境已经无法捕捉,因此只能当作参数传入第二段
    5.Promise
        1.回调函数并没有问题,问题出现在多个回调函数嵌套上
            现多重嵌套,代码不是纵向发展,而是横向发展,很快就会乱成一团
            多个异步操作形成了强耦合,只要有一个操作需要操作,它的上层回调函数和下层回调函数都要跟着修改
            这就是回调函数地狱
        2.Promise对象为了解决回调函数地狱,允许将回调函数的嵌套改写成链式调用
        3.缺点:代码冗余,无论什么操作,都是许多then的堆积
    6.Generator函数
        奥妙在于其中的yield命令,执行到此处,执行权交给其他协程
            遇到yield就暂停,等执行权返回,再从暂停的地方继续往后执行
    7.Thunk函数
        自动执行Generator的一种方法
    8.迭代器生成函数,被调用不会立即被执行,而是返回一个迭代器,然后可以进行异步调用
        同时还可以挂起操作
##async函数
    1.ES7提供了async函数，该函数就是Generator函数的语法糖。
    2.Async函数就是将Generator函数的*替换成async，将yield替换成await。
    3.改进：
        1.自带内置执行器
        2.更好的语义
        3.更广的适用性
        4.返回值是Promise对象
        async函数完全可以看作多个异步操作，包装成的一个Promise对象
        而await命令就是内部then命令的语法糖
    4.语法：
        1.async函数返回一个Promise对象。
        2.只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数
        3.await命令后面是一个promise对象，如果不是会被转成一个立即resolve的Promise对象。
        4.如果await后面的异步操作出错，那么async函数返回的Promise对象被reject。
    5.async的实现原理
        将Generator函数和自动执行器包装在一个函数里
##Class的基本语法
    1.ES6引入class作为对象的模板,通过class关键字定义类
    2.constructor方法
        类的默认方法,通过new命令来生成对象实例时自动调用此方法
        默认返回实例对象(即this),也可以返回另一个对象
##Class的继承
    1.使用extends关键字来实现继承,ES5通过修改原型链实现继承
        class Ponit{}
        class ColorPoint extends Point{}
    2.super:表示父类的构造函数,用来新建父类的this对象
        子类必须在constructor方法中调用super方法,否则新建实例的时候就会出错,子类没有自己的this对象
        而是继承的父类的this对象,然后对其加工,否则子类得不到this对象
    3.Object.getPrototypeOf()
        可以用来从子类上获取父类
    4.super关键字
    5.Mixin模式:将多个类的接口"混入"另一个类中
##修饰器
    1.Decorator是一个函数,用来修改类的行为,ES7引入,已被Babel支持
        @decorator
        class A {}
    2.修饰器还可以修饰类的属性
    3.因为存在函数提升,不能用于函数
##Module的语法
    1.JS一直没有模块功能,无法将大程序拆分成相互依赖的小文件,再用简单的方法将它们拼接起来
        ES6之前就提出来CommonJS和AMD前者用于服务器,后者用于浏览器
        ES6在语言规格的层面上实现了模块功能
        ES6模块的设计思想尽量静态化,使得编译的时候就可以确定模块之间的依赖关系,以及输入和输出的变量
        CommonJS和AMD只能在运行时确定这些东西
    2.ES6模块不是对象,通过export命令显式指定输出的代码,再通过import命令输入
        可以在编译的时候完成了模块加载,导致ES6模块本身无法被引用,因为它不是对象
    3.export
        模块功能主要由两个命令构成,export/import
            1.export:规定模块的对外接口
            2.import:输入其他模块的功能
        一个模块就是一个独立的文件,该文件内部的所有变量,外部是无法获取的,必须使用export输出这个变量
        还可以输出函数或类
        必须和模块内部的变量建立一一对应的关系
    4.import    
        1.使用import加载这个模块
        2.使用整体加载(*)来指定一个对象
        3.使用export default命令为模块指定默认输出
        4.模块之间也可以继承
##Module的加载实现
    1.默认情况下,浏览器同步加载JS脚本,即渲染到<script>标签就会停下来
      等脚本执行完再继续向下渲染,如果是外部脚本,还必须加入脚本下载的时间
    2.通过在<script>里加入defer/async属性,脚本就会异步加载
        1.defer:等到页面正常渲染完后执行
        2.async:一旦下载完成就会中断渲染,执行完这个脚本后继续渲染
    3.对带有type="module"的<script>浏览器都是异步加载的,不会造成浏览器堵塞
    4.ES6模块和CommonJS模块的差异
        1.Common.JS模块输出一个值的复制,ES6输出一个值的引用
        2.Common.JS模块是运行时加载,ES6是编译时输出接口
        3.Common.JS加载的是一个对象(module.exports),只有在脚本运行结束时候才会生成
        4.ES6模块不是对象,对外接口是一种静态定义,在代码静态解析阶段就会生成
        5.Common.JS模块输出的是值的复制,一旦输出一个值,模块内部的变化就影响不到这个值
    5.Node加载
        自己的Common.JS模块和ES6模块不兼容,将两者分开,各自采用各自的加载方案
    6.require命令加载ES6模块
        ES6模块的所有输出接口都会成为输入对象的属性
    7.Common.JS模块的加载原理
        Common.JS的一个模块就是一个脚本文件,require命令第一次加载该脚本时就会执行整个脚本
        然后在内存中生成一个对象
        该对象的ID属性是模块名,exports属性是模块输出的各个接口,loader属性是一个布尔值
        表示该模块的脚本是否执行完毕
        无论Common.JS加载多少次,都只会在第一次加载时运行一次,以后再加载就返回第一次运行的结果
        除非手动清除缓存
    8.Common.JS模块的循环加载
    9.ES6模块的循环加载