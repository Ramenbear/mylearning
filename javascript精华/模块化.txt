1.早期的JavaScript只是作为一种简单的脚本语言，甚至没有类的概念，更不用说模块（module）
    JavaScript越来越不容易支撑住发展的越来越快的前端
2.CommonJS
    1、CommonJS规范,一个单独的文件就是一个模块,每一个模块都是一个单独的作用域，也就是说
        在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性
    2、模块输出：模块只有一个出口，module.exports对象
    3、加载模块：加载模块使用require方法，
        该方法读取一个文件并执行，返回文件内部的module.exports对象
    4.服务器端，同步方式来引入模块，输出的是值的拷贝
3.AMD
    1.异步模块定义,需要用到requireJS
    2.requireJS:
        1.多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器
        2.js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长
    3.定义模块
        define(id?, dependencies?, factory);
            1.id：可选参数，用来定义模块的标识，如果没有提供该参数脚本文件名（去掉拓展名）
            2.dependencies：是一个当前模块依赖的模块名称数组
            3.factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次
                如果是对象，此对象应该为模块的输出值
    4.require([dependencies], function(){});
        1.第一个参数是一个数组，表示所依赖的模块
        2.第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用
            加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块
    5.require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，
        它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题
    6.模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致
        而 CMD在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，
        进入回调函数逻辑，遇到 require 语句的时候才执行对应的模块，
        这样模块的执行顺序就和我们书写的顺序保持一致了
4.CMD
    1.国内发展出来的,需要seaJS
    2.AMD推崇依赖前置,在定义模块的时候就要声明其依赖的模块,方便js知道依赖模块是谁
        CMD推崇就近依赖，只有在用到某个模块的时候再去require,解析模块为字符串
5.ES6
    1.每一个模块只加载一次,每一个JS只执行一次,如果下次再去加载同目录下同文件
        直接从内存中读取。 一个模块就是一个单例，或者说就是一个对象，输出的是值的引用；
    2.每一个模块内声明的变量都是局部变量,不会污染全局作用域；
    3：模块内部的变量或者函数可以通过export导出；
    4：一个模块可以导入别的模块
    5.export (default)
        import

