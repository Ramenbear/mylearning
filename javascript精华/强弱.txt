编译时就知道变量类型的是静态类型；运行时才知道一个变量类型的叫做动态类型。

不允许隐式转换的是强类型，允许隐式转换的是弱类型

高级版本

需要先介绍一些基本概念：

Program Errors（程序错误）

trapped errors：导致程序终止执行（程序意识到出错，使用对应的错误处理机制），如除 0，Java 中数组越界访问
untrapped errors：程序出错后继续执行（其实并不一定保证继续执行，程序本身并不知道出错，也没有对应的错误处理机制），如 C 语言里的缓冲区溢出，Jmp 到错误地址
Forbidden Behaviors（禁止行为）

程序在设计的时候会定义一组 forbidden behaviors，包括了所有的 untrapped errors，可能包括 trapped errors。

Well behaved、ill behaved

well behaved: 如果程序的执行不可能出现 forbidden behaviors，则称为 well behaved
ill behaved: 只要有可能出现 forbidden behaviors，则称为 ill behaved
他们之间的关系可以用下图来表达：


从图中可以看出，绿色的 program 表示所有程序（所有程序，你能想到和不能想到的），error 表示出错的程序，error 不仅仅包括 trapped error 和 untrapped error。

根据图我们可以严格的定义动态类型，静态类型；强类型，弱类型

强类型：如果一门语言写出来的程序在红色矩形外部，则这门语言是强类型的，也就是上面说的 well behaved
弱类型：如果一门语言写出来的程序可能在红色矩形内部，则这门语言是弱类型的，也就是上面说的 ill behaved
静态类型：一门语言在编译时排除可能出现在红色矩形内的情况（通过语法报错），则这门语言是静态类型的
动态类型：一门语言在运行时排除可能出现在红色矩形内的情况（通过运行时报错，但如果是弱类型可能会触发 untrapped error，比如隐式转换，使得程序看起来似乎是正常运行的），则这门语言是动态类型的
举个栗子：

在 Python 中执行 test = '666' / 3 你会在运行时得到一个 TypeError 错误，相当于运行时排除了 untrapped error，因此 Python 是动态类型，强类型语言。

在 JavaScript 中执行 var test = '666' / 3' 你会发现 test 的值变成了 222，因为这里发生了隐式转换，因此 JavaScript 是动态类型，弱类型的。更为夸张的是 [] == ![] 这样的代码在 JavaScript 中返回的是 true，这里是具体的 原因。

在 Java 中执行 int[] arr = new int[10]; arr[0] = '666' / 3; 你会在编译时期得到一个语法错误，这说明 Java 是静态类型的，执行 int[] arr = new int[10]; arr[11] = 3; 你会在运行时得到数组越界的错误（trapped error），这说明 Java 通过自身的类型系统排除了 untrapped error，因此 Java 是强类型的。

而 C 与 Java 类似，也是静态类型的，但是对于 int test[] = { 1, 2, 3 }; test[4] = 5; 这样的代码 C 语言是没办法发现你的问题的，因此这是 untrapped error，因此我们说 C 是弱类型的。

下图是常见的语言类型的划分：


另外，由于强类型语言一般需要在运行时运行一套类型检查系统，因此强类型语言的速度一般比弱类型要慢，动态类型也比静态类型慢，因此在上述所说的四种语言中执行的速度应该是 C > Java > JavaScript > Python。但是强类型，静态类型的语言写起来往往是最安全的。

 动态类型与静态类型的区别，如何利用好动态类型

静态类型由于在编译期会进行优化，所以一般来说性能是比较高的。而动态语言在进行类型操作的时候（比如字符串拼接，整数运算）还需要解释器去猜测其类型，因此性能很低；但是现代的解释器一般会有一些优化措施来提升速度，拿 JavaScript 的 V8 解释器举个栗子：

V8 的优化过程（粗略版本）

我们知道，像 Java / C++ 这样的静态类型语言对于对象一般都会有个类模板（一般调用函数的时候都是去类模板找的）。而像 V8 这种则是会在运行时创建类模板，从而在访问属性或调用方法的时候仅需要计算该属性在类模板中的偏移就可以了；传统的 JavaScript 对象一般是通过 Hash 或 Trie 树实现的，但是查找的效率很低。拿一段代码举例：

function Point(x, y) { 
this.x = x; 
this.y = y; 
} 
var p1 = new Point(1, 2);
在使用 new 调用 Point 函数的时候会先生成一个 class0 类模板（运行时生成），执行 this.x = x 的时候会生成 class1 类模板，执行 this.y = y 的时候会生成 class2 类模板。具体的转换过程如下图：


为一个对象确定一个类模板可以极大的提升属性的访问速度，类模板的确定就是通过走图里的路径（转换路径）。每当你增加或删除对象的属性的时候都会导致对象的类模板发生改变，甚至你增加的顺序不同也会生成不同的类模板！

V8 如果发现一个方法被调用（传入相同类型的参数）多次时，会使用 JIT 将函数编译成二进制代码，从而提升速度。

结合 V8 总结的优化方案：

不要轻易的增加删除一个对象的属性，对于已有的属性尽量做到保证类型的不变，保证隐藏类尽可能被复用
实例化属性的时候尽可能保证属性添加的顺序一致性，保证隐藏类和优化代码可以被复用
尽可能重复调用方法，传的参数的个数和类型要在多次调用时要保持一致
对于数组，最好使用 push，unshift 等方法去改变数组大小，紧密的数组在 V8 中是以连续的地址存的，不要随意去删除数组中的元素，因为稀疏数组在 V8 中是一个 hash 表
V8 存储整数用的是 4 个字节，出现大整数时将会涉及到隐式类型转换，性能降低，因此尽量不要让整数超过 32 bit
 如何避免弱类型语言所带来的问题
弱类型语言由于在运行时缺乏类型系统，因此很容易出现类型操作上的 untrapped error；C 语言中我们前面介绍了数组访问越界的情况，这里我们以弱类型语言 JavaScript 为例：

尽量使用严格比较符号，如：===
尽量不要让字符串与其他类型的变量进行运算操作
复杂对象不要在运算符上进行操作
语言类型静态化的方案
像 JavaScript 这种动态类型的语言静态化后对运行时的安全性，效率肯定会有很大的提升的，目前有 TypeScript 这种预编译的方案；还有就是像 flow 这样的通过注释来标识类型的方案。