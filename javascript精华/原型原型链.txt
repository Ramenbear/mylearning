1.JS受Java的影响,数据类型都是对象类型,那么必须要一套继承机制
2.Java通过new的方式,通过类生成了一个实例对象,但是JS中并不存在类的概念
    但是他们都存在一个共同点,就是都有构造函数
    Java是内部调用了构造函数,于是JS把new一个类设计成了new一个构造函数
    构造函数成为了一个实例对象的原型对象
3.为什么要设计原型对象
    上面的原型设计有一个致命的缺点:无法共享公共属性
    每次new出来的对象,生成的实例都是都是两个不同的对象
    共有的属性也不是共享的,所以需要一个原型对象专门存储对象的共有属性
4.什么是原型对象
    1.给构造函数加一个属性叫prototype属性,指向原型对象
        把实例对象的所用共有属性都放在这个构造函数的prototype属性指向的原型对象中
        不需要共享的都放在构造函数中
    2.JS中函数拥有对象的所有能力,比如添加属性,函数当做参数传递
    3.实例对象一旦通过构造函数创建,就会自动给实例对象赋值上原型对象的属性和方法
        也就是该对象属性都指向了原型对象的属性值
5.对象和函数在原型链中的关系
    1.构造函数的prototype指向原型对象,原型对象有一个constructor属性指回构造函数
        每一个构造函数生成的实例对象都有一个proto属性,也指向原型对象
    2.JS对象都是继承至一个叫做Object对象
        Object构造函数创造了万物
        只要是对象就会有一个_proto_:指向自身构造函数的原型对象
6.原型链
    1.每个对象都有一个_proto_属性指向原型对象,原型对象也有_proto_指向它的原型对象
        直到指向null,也就到达了原型链的顶端
    2.所有函数(包括构造函数)是Function的实例,所以所有函数的_proto_都指向Function的原型对象
    3.所有的原型对象(Function原型)都是Object的实例
        所有_proto_都指向Object(构造函数)的原型对象,Object构造函数的_proto_指向null
    4.Function构造函数本身就是Function的实例,_proto_指向Function的原型对象
7.instanceof
    判断该对象的原型链中是否可以找到该构造函数的prototype类型