1.JS是单线程的,这也就意味着阻塞问题,所以不得不出现同步和异步解决方案
2.为什么单线程?
    用户的交互和操作DOM决定了JS单线程
    多线程会带来复杂的同步问题,需要加锁,执行任务非常繁重
    虽然H5规定JS脚本可以创建多个线程,但是子线程完全受主线程控制,且不得操作DOM
3.异步编程
    1.回调函数
        特定的事件或条件发生的时候由另一方调用,用于响应
    2.为什么不能捕获异常
        JS的运行机制有关,异步任务执行会加入到任务队列
        当执行栈没有可执行任务了,主线程取出任务队列中的异步任务并入栈执行
        异步任务执行的时候,捕获异常的函数早就出栈了
    3.return只能终止回调函数的执行,不能终止外部代码的执行
4.异步代码执行顺序,EventLoop运行机制
    1.执行上下文
        代码执行的一个环境
            1.全局执行上下文
            2.函数执行上下文
            3.Eval执行上下文
    2.运行机制
        1.<script>标签开始,作为一个宏任务
        2.宏任务分配到相应的宏任务队列
        3.微任务分配到相应的微任务队列
        4.<script>标签代码执行完,宏/微任务分配完成
        5.宏/微任务执行完,进行第一次渲染
        6.开始第二轮消息循环
5.defer:渲染完再执行
    async:下载完就执行
    动态创建DOM方式（用得最多）
    按需异步载入js
